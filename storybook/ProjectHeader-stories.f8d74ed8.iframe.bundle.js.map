{"version":3,"file":"ProjectHeader-stories.f8d74ed8.iframe.bundle.js","mappings":";;AAOA;;;AAGA;AAUA;;;ACXA;AACA;AAGA;;;;;;ACJA;;;AAGA;;;AAGA;;;AAKA;AACA;AAGA;;;;;;AAQA;;;ACrBA;;AAIA;AACA;;;;AAIA;;;AAKA;;;AAKA;;;;AAIA;AACA;AAGA;AACA;;;;;;AAMA;;AAIA;;;;AAMA;AAGA;;AAIA;AACA;AAGA;AACA;;;;;;AAQA","sources":["webpack://dovotori/./src/components/Tag.jsx","webpack://dovotori/./src/components/TagsList.jsx","webpack://dovotori/./src/components/TypingMessage.jsx","webpack://dovotori/./src/components/ProjectHeader.jsx"],"sourcesContent":["import styled from \"styled-components\";\nimport { getColorType } from \"../utils\";\n\n// import Logotype from './Logotype'\n\nconst Wrap = styled.span`\n  font-size: 0.8em;\n  color: ${(p) => p.theme.text};\n  white-space: nowrap;\n  margin: 0;\n  border-bottom: solid 2px ${(p) => p.theme.getColor ?? p.theme.primary};\n`;\n\n// const StyledLogotype = styled(Logotype)`\n//   display: inline-block;\n//   width: 10px;\n//   filter: grayscale(100%);\n//   margin-right: 5px;\n// `\n\nexport default ({ className, label, category, picto, hidePicto = true }) => {\n  const $colorType = getColorType(category);\n  return (\n    <Wrap className={className} $colorType={$colorType}>\n      {/* {picto && !hidePicto ? <StyledLogotype name={picto} /> : null} */}\n      {label}\n    </Wrap>\n  );\n};\n","import { Fragment } from \"react\";\nimport styled from \"styled-components\";\n\nimport Tag from \"./Tag\";\n\nconst Wrap = styled.p`\n  letter-spacing: 0.1em;\n  margin: 0 0 1em;\n`;\nconst Span = styled.span`\n  color: ${(p) => p.theme.midl};\n`;\n\nconst TagsList = ({ className, tags }) => {\n  return (\n    <Wrap className={className}>\n      {tags.map(({ label, slug, categoryId, picto }, id) => (\n        <Fragment key={slug}>\n          {id !== 0 ? <Span> / </Span> : null}\n          <Tag label={label} category={categoryId} picto={picto} />\n        </Fragment>\n      ))}\n    </Wrap>\n  );\n};\n\nexport default TagsList;\n","import { useCallback, useEffect, useRef } from \"react\";\nimport styled from \"styled-components\";\n\nconst Wrap = styled.div`\n  position: relative;\n\n  p {\n    display: flex;\n    flex-wrap: wrap;\n    flex-direction: ${(p) => (p.$isVertical ? \"column\" : \"row\")};\n    line-height: 1;\n    align-items: center;\n    justify-content: ${(p) => (p.$isCenter ? \"center\" : \"flex-start\")};\n\n    span {\n      margin: 0 ${(p) => (p.$isVertical ? 0 : \"0.2em\")} 0 0;\n    }\n  }\n`;\n\nconst Hidden = styled.p`\n  visibility: ${(p) => (p.$isVisible ? \"visible\" : \"hidden\")};\n`;\n\nconst Anim = styled.p`\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  transition: color 500ms linear;\n`;\n\nconst CHARS = \"!<>-_\\\\/[]{}â€”=+*^?#\";\nconst Modes = {\n  DISAPPEAR: -1,\n  APPEAR: 1,\n  STOP: 0,\n};\n\nconst TypingMessage = ({\n  message = \"\",\n  isDisabled = false,\n  isVertical = false,\n  isCenter = false,\n  firstMessage = \"\",\n  className,\n  isLoop = false,\n  delayLoop = 5000, // en ms\n  delayLetter = 100, // en ms\n  trigger = 0, // increment to replay animation\n  triggerDebounce = 500, // debounce delay for trigger in ms\n}) => {\n  const count = useRef(0);\n  const lastFrame = useRef(Date.now());\n  const req = useRef(null);\n  const timeout = useRef(null);\n  const fromMessage = useRef(firstMessage);\n  const toMessage = useRef(message);\n  const mode = useRef(Modes.STOP);\n  const lastTriggerTime = useRef(0);\n  const displayMessage = useRef(firstMessage);\n  const animRef = useRef(null);\n\n  const randomChar = useCallback(\n    () => CHARS[Math.floor(Math.random() * CHARS.length)],\n    [],\n  );\n  const randomStr = useCallback(\n    (length) => new Array(length).fill(0).map(randomChar).join(\"\"),\n    [randomChar],\n  );\n  const randomCurrentStr = useCallback(\n    (str) =>\n      str\n        .split(\"\")\n        .map((car) => {\n          if (car === \" \") return car;\n          if (Math.random() > 0.5) return randomChar();\n          return car;\n        })\n        .join(\"\"),\n    [randomChar],\n  );\n\n  // Direct DOM update - no React re-render\n  const updateDOM = useCallback((text) => {\n    displayMessage.current = text;\n    if (animRef.current) {\n      animRef.current.innerHTML = text\n        .split(\"\")\n        .map((letter) => `<span>${letter === \" \" ? \"_\" : letter}</span>`)\n        .join(\"\");\n    }\n  }, []);\n\n  const update = useCallback(() => {\n    const now = Date.now();\n    const milli = now - lastFrame.current;\n    if (milli < delayLetter) {\n      req.current = requestAnimationFrame(update);\n      return;\n    }\n\n    let text = \"\";\n    switch (mode.current) {\n      case Modes.APPEAR: {\n        if (count.current < toMessage.current.length) {\n          count.current++;\n          text = toMessage.current.substring(0, count.current);\n          text = randomCurrentStr(text);\n        } else {\n          text = toMessage.current;\n          fromMessage.current = toMessage.current;\n          mode.current = Modes.STOP;\n        }\n        break;\n      }\n      case Modes.DISAPPEAR: {\n        if (count.current > 0) {\n          count.current--;\n          text = fromMessage.current.substring(0, count.current);\n          text = randomCurrentStr(text);\n        } else {\n          count.current++;\n          mode.current = Modes.APPEAR;\n          text = randomStr(count.current);\n        }\n        break;\n      }\n      default:\n        break;\n    }\n\n    updateDOM(text);\n    lastFrame.current = now;\n\n    if (mode.current !== Modes.STOP) {\n      req.current = requestAnimationFrame(update);\n    } else if (mode.current === Modes.STOP && isLoop) {\n      if (timeout.current) {\n        clearTimeout(timeout.current);\n      }\n      timeout.current = setTimeout(() => {\n        mode.current = Modes.DISAPPEAR;\n        req.current = requestAnimationFrame(update);\n      }, delayLoop);\n    }\n  }, [isLoop, delayLoop, delayLetter, randomStr, randomCurrentStr, updateDOM]);\n\n  useEffect(() => {\n    if (timeout.current) {\n      clearTimeout(timeout.current);\n    }\n\n    if (!isDisabled) {\n      const old = displayMessage.current;\n      let nextMode = Modes.STOP;\n\n      // determine le mode\n      if (old.length === 0 && message.length > 0) {\n        nextMode = Modes.APPEAR;\n        count.current = 0;\n      } else if (old.length > 0 && message.length > 0) {\n        nextMode = Modes.DISAPPEAR;\n        count.current = old.length;\n      } else {\n        nextMode = Modes.STOP;\n      }\n\n      if (req.current) {\n        cancelAnimationFrame(req.current);\n      }\n      if (nextMode !== Modes.STOP) {\n        fromMessage.current = old;\n        toMessage.current = message;\n        lastFrame.current = Date.now();\n        mode.current = nextMode;\n        req.current = requestAnimationFrame(update);\n      }\n    }\n    return () => {\n      if (req.current) {\n        cancelAnimationFrame(req.current);\n      }\n    };\n  }, [message, isDisabled, update]);\n\n  useEffect(() => {\n    if (timeout.current) {\n      clearTimeout(timeout.current);\n    }\n    if (isLoop) {\n      timeout.current = setTimeout(() => {\n        mode.current = Modes.DISAPPEAR;\n        req.current = requestAnimationFrame(update);\n      }, delayLoop);\n    }\n    return () => {\n      if (timeout.current) {\n        clearTimeout(timeout.current);\n      }\n    };\n  }, [isLoop, delayLoop, update]);\n\n  useEffect(\n    () => () => {\n      if (req.current) {\n        cancelAnimationFrame(req.current);\n      }\n      if (timeout.current) {\n        clearTimeout(timeout.current);\n      }\n    },\n    [],\n  );\n\n  // Replay animation when trigger changes (with throttle)\n  // biome-ignore lint/correctness/useExhaustiveDependencies: only trigger on trigger change\n  useEffect(() => {\n    if (trigger > 0 && !isDisabled) {\n      const now = Date.now();\n      if (now - lastTriggerTime.current < triggerDebounce) return;\n      lastTriggerTime.current = now;\n\n      if (req.current) {\n        cancelAnimationFrame(req.current);\n      }\n      if (timeout.current) {\n        clearTimeout(timeout.current);\n      }\n      count.current = displayMessage.current.length;\n      fromMessage.current = displayMessage.current;\n      toMessage.current = message;\n      mode.current = Modes.DISAPPEAR;\n      lastFrame.current = now;\n      req.current = requestAnimationFrame(update);\n    }\n  }, [trigger]);\n\n  // Initialize DOM on mount\n  useEffect(() => {\n    updateDOM(firstMessage);\n  }, [firstMessage, updateDOM]);\n\n  return (\n    <Wrap className={className} $isVertical={isVertical} $isCenter={isCenter}>\n      <Hidden $isVisible={isDisabled}>\n        {message.split(\"\").map((letter, index) => {\n          const key = `${message}${letter}${index}`;\n          return <span key={key}>{letter === \" \" ? `_` : letter}</span>;\n        })}\n      </Hidden>\n      <Anim ref={animRef} />\n    </Wrap>\n  );\n};\n\nexport default TypingMessage;\n","import styled from \"styled-components\";\n\nimport { ReactComponent as LinkSvg } from \"Assets/svg/externalLink.svg\";\nimport TagsList from \"./TagsList\";\nimport TypingMessage from \"./TypingMessage\";\n\nconst WrapContent = styled.div`\n  margin: 0 auto;\n  max-width: 800px;\n`;\n\nconst WrapTexte = styled.div`\n  margin-top: 6em;\n`;\n\nconst Description = styled.div`\n  color: ${(p) => p.theme.light};\n  width: 100%;\n  padding: 10px;\n\n  ${(p) => p.theme.media.tablet`\n    width: 100%;\n  `};\n`;\n\nconst Text = styled.p`\n  margin: 10px 0;\n  width: 100%;\n`;\n\nconst Date = styled.p.attrs({ className: \"numbers\" })`\n  text-align: left;\n  margin: 0;\n  padding: 0.4em 10px 0;\n  color: ${(p) => p.theme.getColor};\n  ${(p) => p.theme.monospace}\n`;\n\nconst StyledTitle = styled.h1`\n  ${(p) => p.theme.title}\n  position: relative;\n  margin: 0;\n  padding: 0 10px;\n\n  & > span > span > span {\n    ${(p) => p.theme.primaryGradientText}\n  }\n`;\n\nconst StyledTypingMessage = styled(TypingMessage)``;\n\nconst Bar = styled.div`\n  width: 100%;\n  height: 1px;\n  margin: 0;\n  background: ${(p) => p.theme.getGradient};\n`;\n\nconst StyledTagsList = styled(TagsList)`\n  margin: 1.4em 0;\n`;\n\nconst A = styled.a`\n  color: ${(p) => p.theme.getColor};\n`;\n\nconst LinkIcon = styled(LinkSvg)`\n  stroke: ${(p) => p.theme.getColor};\n  fill: none;\n  width: 1em;\n  height: 1em;\n  margin-left: 0.5em;\n  transform: translateY(1px);\n`;\n\nconst ProjectHeader = ({\n  title,\n  inverseTitle,\n  descriptions,\n  tags,\n  date,\n  links,\n  textSite,\n  $colorType,\n}) => (\n  <WrapContent>\n    <WrapTexte>\n      {date && <Date $colorType={$colorType}>{date}</Date>}\n      {title && (\n        <StyledTitle $colorType={$colorType}>\n          <StyledTypingMessage message={title} />\n        </StyledTitle>\n      )}\n      {descriptions || tags || link ? (\n        <>\n          <Bar $colorType={$colorType} />\n          <Description>\n            {descriptions?.map((text) => (\n              <Text key={text}>{text}</Text>\n            ))}\n            {tags?.length ? <StyledTagsList tags={tags} /> : null}\n            {links\n              ? links.map((link) => (\n                  <A\n                    key={link.url}\n                    href={link.url}\n                    target=\"_blank\"\n                    rel=\"noreferrer\"\n                    $colorType={$colorType}\n                  >\n                    {link.label}\n                    <LinkIcon $colorType={$colorType} />\n                  </A>\n                ))\n              : null}\n          </Description>\n        </>\n      ) : null}\n    </WrapTexte>\n  </WrapContent>\n);\n\nexport default ProjectHeader;\n"],"names":[],"ignoreList":[],"sourceRoot":""}