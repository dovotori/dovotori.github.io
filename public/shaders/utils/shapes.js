import{PI,TWO_PI}from"./index";import{funcNoise,funcPnoise,funcSnoise}from"./noise";export const rect="\nfloat rect(vec2 uv, vec2 start, vec2 size) {\n  vec2 leftTop = step(start, uv);\n  // vec2 bottomRight = step(vec2(1.0 - (x + w), 1.0 - (y + h)), 1.0 - uv);\n  vec2 bottomRight = step(vec2(1.0) - (start + size), 1.0 - uv);\n  return leftTop.x * leftTop.y * bottomRight.x * bottomRight.y;\n}\n";export const circle="\nfloat circle(vec2 uv , vec2 center, float radius){\n  vec2 dist = uv - center;\n\treturn 1.0 - smoothstep(\n    radius - (radius * 0.01), radius + (radius * 0.01), dot(dist, dist) * 4.0\n  );\n}";export const distanceField="\nfloat distanceField(vec2 uv, float size, float distorsion) {\n  // Remap the space to -1. to 1.\n  vec2 st = uv * 2.0 - 1.0;\n\n  // Make the distance field\n  float d = length( abs(st) - distorsion ); \n  // float d = length( min(abs(st) - distorsion, 0.0) );\n  // float d = length( max(abs(st) - distorsion, 0.0) ); \n\n  return fract(d * size);\n}";export const polar="\nfloat polar(vec2 uv, vec2 center, float size) {\n  vec2 pos = center - uv;\n\n  float r = length(pos) * size;\n  float a = atan(pos.y, pos.x);\n\n  float f = 0.0;\n  f = cos(a * 3.0);\n  // f = abs(cos(a * 3.0));\n  // f = abs(cos(a * 2.5)) * 0.5 + 0.3;\n  // f = abs(cos(a * 12.0) * sin(a * 3.0)) * 0.8 + 0.1;\n  // f = smoothstep(-0.5, 1.0, cos(a * 10.0)) * 0.2 + 0.5;\n\n  return 1.0 - smoothstep(f, f + 0.02, r);\n}";export const polygon=`\n${PI}${TWO_PI}\n\nfloat polygon(vec2 uv, int nb, float size) {\n  float d = 0.0;\n\n  // Remap the space to -1. to 1.\n  vec2 st = uv  * 2.0 - 1.0;\n\n  // Number of sides of your shape\n  int N = nb;\n\n  // Angle and radius from the current pixel\n  float a = atan(st.x, st.y) + PI;\n  float r = TWO_PI / float(N);\n\n  // Shaping function that modulate the distance\n  d = cos(floor(0.5 + a / r) * r - a) * length(st) * (1.0 / size);\n\n  return 1.0 - smoothstep(0.4, 0.41, d);\n}`;export const concentricCircles="\nfloat concentricCircles(vec2 uv, float distance, float step) {\n  vec2 center = 2.0 * (uv - vec2(0.5));\n  float r = length(center);\n  float a = atan(center.y, center.x);\n  return pow(max(0.0, sin(step * log(r))), distance);\n}\n";export const fluid=`\n${PI}\nvec4 fluid(vec2 uv, vec2 scale, float time) {\n  float v = 0.0;\n    vec2 c = uv * scale - scale / 2.0;\n    v += sin((c.x + time));\n    v += sin((c.y + time) / 2.0);\n    v += sin((c.x + c.y + time)/2.0);\n    c += scale / 2.0 * vec2(sin(time / 3.0), cos(time / 2.0));\n    v += sin(sqrt(c.x * c.x + c.y * c.y + 1.0) + time);\n    v = v/2.0;\n    vec3 col = vec3(1.0, sin(PI * v), cos(PI * v));\n    return vec4(col * 0.5 + 0.5, 1.0);\n}\n`;export const planet=`\n${PI}\n${funcNoise}\n${funcPnoise}\n${funcSnoise}\nfloat clouds( vec2 coord ) {\n  // standard fractal\n  float n = snoise(vec3(coord, 1.0));\n  n += 0.5 * snoise(vec3(coord * 2.0, 1.0));\n  n += 0.25 * snoise(vec3(coord * 4.0, 1.0));\n  n += 0.125 * snoise(vec3(coord * 8.0, 1.0));\n  n += 0.0625 * snoise(vec3(coord * 16.0, 1.0));\n  n += 0.03125 * snoise(vec3(coord * 32.0, 1.0));\n  n += 0.03125 * snoise(vec3(coord * 32.0, 1.0));\n  return n;\n}\n\nvec4 planet(vec2 uv, float size, vec2 rotation) {\n  vec2 norm = 2.0 * uv - 1.0;\n\n  float r = length(norm) / size;\n  float phi = atan(norm.y, norm.x);\n  \n  // spherize\n  r = 2.0 * asin(r) / PI;\n  \n  vec2 coord = vec2(r * cos(phi), r * sin(phi));\n  coord = coord / 2.0 + 0.5;\n\n  coord += rotation;\n  float n = clouds(coord * 3.0);\n  \n  vec2 position = uv - 0.5;\n  float len = length(position);\n  \n  // block out some terrain\n  float terrain = smoothstep(0.1, 0.0, n); \n  \n  // green\n  vec3 terrainColor = vec3(76.0 / 255.0, 147.0 / 255.0, 65.0 / 255.0); \n  terrainColor = mix(\n    vec3(131.0 / 255.0, 111.0 / 255.0, 39.0 / 255.0),\n    terrainColor,\n    smoothstep(0.2, .7, 1.0 - n)\n  );\n  \n  //mix in brown edge\n  terrainColor = mix(\n    vec3(94.0 / 255.0, 67.0 / 255.0, 31.0 / 255.0), \n    terrainColor, \n    smoothstep(0.0, 0.18, n)\n  );\n  terrainColor += n * 0.3;\n  \n  // water\n  vec3 color = vec3(81.0 / 255.0, 121.0 / 255.0, 181.0 / 255.0); \n  color -= (1.0 - n * 4.0) * 0.03;\n  \n  // mix terrain with water\n  color = mix(terrainColor, color, terrain); \n  \n  // anti-alias\n  color *= smoothstep(0.5 * size, 0.495 * size, len);\n  // shadow\n  color *= smoothstep(0.625 * size, 0.25 * size, len);\n  color = clamp(color, 0.0, 1.0);\n  float opacity = 1.0;\n  if (color == vec3(0.0)) {\n    opacity = 0.0;\n  }\n  return vec4(color, opacity);\n}\n`;