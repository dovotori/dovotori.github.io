import{PI}from".";import{anothorNoise2D}from"./noise";export const getNaturalHeight=`\n${anothorNoise2D}\n\n#define NB_OCTAVES 10\nuniform float lacunarity; // frequency of noise octave\nuniform float persistance; // influence of noise octave\n\nuniform vec2 moving;\nuniform vec2 gridSize;\n\nfloat getNaturalHeight(vec2 coor) {\n  float result = 0.0;\n  float allAmpli = 0.0;\n  for(int i = 0; i < NB_OCTAVES; i += 1) {\n    float frequency = pow(lacunarity, float(i));\n    float amplitude = pow(persistance, float(i));\n    result += noise(coor * frequency) * amplitude;\n    allAmpli += amplitude;\n  }\n  return result / allAmpli;\n}`;export const locations=["octaves","lacunarity","persistance","moving","gridSize"];export const funcWave=`\n${PI}\n\nstruct Wave {\n  vec3 position;\n\tvec3 tangent;\n\tvec3 binormal;\n};\n\nWave funcWave(\n  vec2 uv,\n  float steepness, // raideur -> steepness prevent looping (replace amplitude) entre 0 et 1\n  float wavelength,\n  vec2 direction,\n  vec2 time,\n  vec3 tangent,\n  vec3 binormal\n) {\n  vec2 D = normalize(direction);\n\tfloat K = 2.0 * PI / wavelength;\n\tfloat C = sqrt(9.8 / K);\n  float F = K * (dot(D, uv) - C * time.y);\n\n\tfloat A = steepness / K;\n\n\tvec3 p = vec3(uv.x, 0.0, uv.y);\n\tp.x += D.x * (A * cos(F));\n\tp.y = A * sin(F);\n\tp.z += D.y * (A * cos(F));\n\n  // on en profite pour update tangent et binormal\n  tangent += vec3(\n    -1.0 - D.x * D.x * (steepness * sin(F)),\n    D.x * (steepness * cos(F)),\n    -D.x * D.y * (steepness * sin(F))\n  );\n\n  binormal += vec3(\n    -D.x * D.y * (steepness * sin(F)),\n    D.y * (steepness * cos(F)),\n    - D.y * D.y * (steepness * sin(F))\n  );\n\n\treturn Wave(\n    p,\n    tangent,\n    binormal\n  );\n}\n`;export const getNormale="\nvec3 computeNormale(vec3 p0, vec3 p1, vec3 p2) {\n  return cross(p1 - p0, p2 - p0);\n}\n\nvec3 roundNormale(vec3 position, vec2 moving) {\n  vec2 betweenPoints = 2.0 / gridSize;\n\n  vec2 coordP0 = position.xz + vec2(betweenPoints.x, 0.0) + moving;\n  vec2 coordP1 = position.xz + vec2(betweenPoints.x, 0.0) + moving;\n  vec2 coordP2 = position.xz + vec2(0.0, betweenPoints.y) + moving;\n  \n  vec3 p0 = vec3(0.0, position.y, 0.0);\n  vec3 p1 = vec3(betweenPoints.x, getNaturalHeight(coordP1), 0.0);\n  vec3 p2 = vec3(0.0, getNaturalHeight(coordP2), betweenPoints.y);\n\n  return normalize(computeNormale(p0, p2, p1));\n}\n\nvec3 getNormale(vec3 position, vec3 tranformed) {\n  vec3 normale = vec3(0.0);\n  if (position.y == 0.0) {\n    normale = roundNormale(tranformed, moving);\n  }\n  if (position.x == 1.0) {\n    normale = vec3(1.0 ,0.0, 0.0);\n  } else if (position.x == -1.0) {\n    normale = vec3(-1.0 ,0.0, 0.0);\n  } else if (position.z == 1.0) {\n    normale = vec3(0.0 ,0.0, 1.0);\n  } else if (position.z == -1.0) {\n    normale = vec3(0.0 ,0.0, -1.0);\n  }\n  return normale;\n}\n";