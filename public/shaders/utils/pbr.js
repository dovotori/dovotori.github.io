import{addLightLocations,uniformLights}from"./light";import{PI}from".";export const uniformPBR="\nuniform vec4 color;\nuniform float metal;\nuniform float rough;\nuniform float ao;\n";export const funcPBR=`\n${PI}\n${uniformLights}\n${uniformPBR}\n\nfloat DistributionGGX(vec3 N, vec3 H, float roughness) {\n  float a      = roughness * roughness;\n  float a2     = a * a;\n  float NdotH  = max(dot(N, H), 0.0);\n  float NdotH2 = NdotH * NdotH;\n  float num   = a2;\n  float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n  denom = PI * denom * denom;\n  return num / denom;\n}\n\nfloat GeometrySchlickGGX(float NdotV, float roughness) {\n  float r = (roughness + 1.0);\n  float k = (r * r) / 8.0;\n  float num   = NdotV;\n  float denom = NdotV * (1.0 - k) + k;\n  return num / denom;\n}\n\nfloat GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness) {\n  float NdotV = max(dot(N, V), 0.0);\n  float NdotL = max(dot(N, L), 0.0);\n  float ggx2  = GeometrySchlickGGX(NdotV, roughness);\n  float ggx1  = GeometrySchlickGGX(NdotL, roughness);\n  return ggx1 * ggx2;\n}\n\nvec3 fresnelSchlick(float cosTheta, vec3 F0) {\n  return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\nvec3 funcPBR(vec3 position, vec3 normale, vec3 posEye) {\t\t\n  vec3 N = normalize(normale);\n  vec3 V = normalize(posEye - position);\n\n  vec3 F0 = vec3(0.04); \n  F0 = mix(F0, color.xyz, metal);\n\n  // reflectance equation\n  vec3 Lo = vec3(0.0);\n  \n  for (int i = 0; i < MAX_LIGHTS; ++i) {\n    if (i < numLights) {\n      // calculate per-light radiance\n      vec3 L = normalize(lights[i].position - position);\n      vec3 H = normalize(V + L);\n      float distance    = length(lights[i].position - position);\n      float attenuation = lights[i].strength / (distance * distance);\n      vec3 radiance     = lights[i].ambiant * attenuation;        \n      \n      // cook-torrance brdf\n      float NDF = DistributionGGX(N, H, rough);        \n      float G   = GeometrySmith(N, V, L, rough);      \n      vec3 F    = fresnelSchlick(max(dot(H, V), 0.0), F0);       \n      \n      vec3 kS = F;\n      vec3 kD = vec3(1.0) - kS;\n      kD *= 1.0 - metal;\t  \n      \n      vec3 numerator    = NDF * G * F;\n      float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0);\n      vec3 specular     = numerator / max(denominator, 0.001);  \n          \n      // add to outgoing radiance Lo\n      float NdotL = max(dot(N, L), 0.0);                \n      Lo += (kD * color.xyz / PI + specular) * radiance * NdotL; \n    }\n  }\n\n  vec3 ambient = vec3(0.03) * color.xyz * ao;\n  vec3 finalColor = ambient + Lo;\n  finalColor = finalColor / (finalColor + vec3(1.0));\n  finalColor = pow(finalColor, vec3(1.0 / 2.2));  \n  return finalColor;\n}\n`;export const locationsPBR=addLightLocations().concat(["color","metal","rough","ao"]);