import{PI}from"../utils";import vertex from"./basicVertex";const rayMarch="\n#define RAY_MARCH_MAX_STEPS 100\n#define RAY_MARCH_MAX_DIST 100.\n#define RAY_MARCH_SURF_DIST .01 // distance where we have a hit\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n\tfloat dO = 0.;\n  for(int i=0; i<RAY_MARCH_MAX_STEPS; i++) {\n    vec3 p = ro + rd*dO;\n    float dS = getSceneDist(p);\n    dO += dS;\n    if(dO > RAY_MARCH_MAX_DIST || dS < RAY_MARCH_SURF_DIST) break;\n  }  \n  return dO;\n}\n",camera="\nvec3 camera(vec3 rayOrigin, vec2 uv) {\n  vec3 lookAtPoint = vec3(0.);\n  float zoom = 1.;\n\n  vec3 forward = normalize(lookAtPoint - rayOrigin);\n  vec3 right = cross(vec3(0.,1.,0.), forward);\n  vec3 up = cross(forward, right);\n\n  vec3 center = rayOrigin + forward * zoom;\n  vec3 intersect = center + uv.x * right + uv.y * up;\n\n  return intersect - rayOrigin; // between eye pos and screen position\n}\n\n",fragment=`\nprecision mediump float;\n\nuniform sampler2D textureMap;\nuniform float time;\n\nvarying vec2 fragTexture;\n\n${PI}\n${camera}\n\nfloat getSceneDist(vec3 point) {\n  vec3 spherePosition = vec3(0., 1., 2.);\n  float sphereRadius = 0.5;\n\n  float sphereDistance = length(point - spherePosition) - sphereRadius;\n  \n  float planeY = -0.4;\n  float planeDistance = point.y - planeY;\n\n  float d = min(sphereDistance, planeDistance);\n  return d;\n}\n\n${rayMarch}\n\nvec3 getNormale(vec3 p) {\n  float distance = getSceneDist(p);\n  vec2 threshold = vec2(.01, 0.);\n  vec3 normale = distance - vec3(\n    getSceneDist(p - threshold.xyy),\n    getSceneDist(p - threshold.yxy),\n    getSceneDist(p - threshold.yyx)\n  );\n  return normalize(normale);\n}\n\nfloat getLight(vec3 p) {\n  vec3 lightPos = vec3(0.,5.,-1.);\n  vec3 lightDir = normalize(lightPos - p);\n  vec3 normale = getNormale(p);\n  float diffuse = clamp(dot(normale, lightDir), 0., 1.);\n\n  // shadow\n  float distranceToLight = rayMarch(p + normale * 0.02, lightDir);\n  if (distranceToLight < length(lightPos - p)) {\n    diffuse *= .1;\n  }\n  return diffuse;\n}\n\nvoid main() {\n  vec2 uv = fragTexture - 0.5; \n\n  vec3 rayOrigin = vec3(0., 1., -4.); // eye pos\n  vec3 rayDirection = camera(rayOrigin, uv);\n\n  float d = rayMarch(rayOrigin, rayDirection);\n  // d /= 6.; // distance is > 1 so we need to lower this arbitrarely\n\n  vec3 p = rayOrigin + rayDirection * d;\n\n\tgl_FragColor = vec4(vec3(getLight(p)), 1.0);\n}\n`;export default{vertex,fragment,attributes:["position","texture"],uniforms:["flipY","textureMap","time"]};