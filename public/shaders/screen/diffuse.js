import{uniformLights,addLightLocations,funcLightAttenuation,funcLightConeAttenuation}from"../utils/light";import vertex from"./basicVertex";const fragment=`\nprecision mediump float;\n\n#define CAP_MAX_DEPTH 0.99 // z limit to compute\n\nuniform sampler2D depthMap;\nuniform sampler2D normalMap;\nuniform sampler2D positionMap;\nvarying vec2 fragTexture;\n\n${uniformLights}\n\n${funcLightAttenuation}\n${funcLightConeAttenuation}\n\nvec4 funcDiffuseColor() {\n  vec3 finalColor = vec3(0.0);\n  float fragDepth = texture2D(depthMap, fragTexture).r * 2.0 - 1.0;\n  if (fragDepth > CAP_MAX_DEPTH) { return vec4(0.0); } // if too far\n\n  vec3 N = texture2D(normalMap, fragTexture).xyz;\n  vec3 P = texture2D(positionMap, fragTexture).xyz;\n  \n  for(int i = 0; i < MAX_LIGHTS; i += 1) {\n    if(i < numLights) {\n      vec3 lightPos = lights[i].position;\n      vec3 L = normalize(lightPos - P);\n      float lambertCosinus = max(dot(N, L), 0.0);\n      vec3 color = lights[i].diffuse * lambertCosinus;\n      float att = 1.0;\n      // if (lights[i].type == 1) {\n      //   att = funcLightAttenuation(lights[i].position, lights[i].radius, N, P);\n      // } else if (lights[i].type == 2) {\n      //   att = funcLightConeAttenuation(lights[i].position, lights[i].direction, N, P);\n      // }\n      color *= lights[i].strength;\n      color *= att;\n      finalColor += color;\n    }\n  }\n  return vec4(finalColor, 1.0);\n}\n\nvoid main() {\n  gl_FragColor = funcDiffuseColor();\n}\n`;export default{vertex,fragment,attributes:["position","texture"],uniforms:["flipY","depthMap","normalMap","positionMap"].concat(addLightLocations())};