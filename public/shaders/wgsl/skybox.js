export default"\nstruct VertexOutput {\n  @builtin(position) position: vec4f,\n  @location(0) pos: vec4f,\n}\n\n@vertex fn v_main(\n  @builtin(vertex_index) vertex_index: u32\n) -> VertexOutput {\n // https://webgpufundamentals.org/webgpu/lessons/webgpu-large-triangle-to-cover-clip-space.html\n // triangle coordinates to have a square in -1 -1 to 1 1\n  let pos = array(\n    vec2f(-1, 3),\n    vec2f(-1,-1),\n    vec2f( 3,-1),\n  );\n\n  var out: VertexOutput;\n  out.position = vec4f(pos[vertex_index], 1, 1);\n  out.pos = out.position; // pass to fragment shader\n  return out;\n}\n\nstruct Uniforms {\n  viewDirectionProjectionInverse: mat4x4f,\n};\n@group(0) @binding(0) var<uniform> uni: Uniforms;\n@group(0) @binding(1) var ourSampler: sampler;\n@group(0) @binding(2) var ourTexture: texture_cube<f32>;\n\nstruct FragInput {\n  @builtin(position) position: vec4f,\n  @location(0) pos: vec4f,\n};\n\nstruct FragOutput {\n  @location(0) color: vec4f,\n  @location(1) color2: vec4f, // not used but need to match pipeline targets\n  @location(2) color3: vec4f, // not used but need to match pipeline targets\n};\n\n@fragment fn f_main(input: FragInput) -> FragOutput {\n  var out : FragOutput;\n  let t = uni.viewDirectionProjectionInverse * input.pos;\n  var color = textureSample(ourTexture, ourSampler, normalize(t.xyz / t.w) * vec3f(1, 1, -1));\n  out.color = color;\n  out.color2 = color;\n  out.color3 = color;\n  return out;\n}\n";