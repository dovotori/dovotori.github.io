export default"\nstruct MaterialUniform {\n  baseColorFactor: vec4f,\n  emissiveFactor: vec3f,\n  roughnessFactor: f32,\n  metallicFactor: f32,\n};\n\n@group(2) @binding(0) var<uniform> material : MaterialUniform;\n@group(2) @binding(1) var baseColorSampler: sampler;\n@group(2) @binding(2) var baseColorTexture: texture_2d<f32>;\n@group(2) @binding(3) var depthMapSampler: sampler_comparison;\n@group(2) @binding(4) var depthMapTexture: texture_depth_2d;\n@group(2) @binding(5) var<uniform> lightPos: vec3f;\n\nstruct PointLight {\n  position: vec3f, \n  color: vec3f, \n  intensity: f32,\n};\n@group(3) @binding(0) var<storage> lights: array<PointLight>;\n\nfn number_of_lights() -> u32 {\n  return arrayLength(&lights);\n}\n\nstruct FragInput {\n  @location(0) world_position: vec3f,\n  @location(1) world_normal: vec3f,\n  @location(2) texture: vec2f,\n  @location(3) camera_position: vec3f,\n  @location(4) shadow_pos: vec3<f32>,\n  @location(5) picking_color: vec4<f32>,\n  @location(6) face_color: f32,\n};\n\n@fragment\nfn f_main(in: FragInput) -> @location(0) vec4f {\n  var color = material.baseColorFactor;\n\n  var baseColorTex = textureSample(baseColorTexture, baseColorSampler, in.texture);\n  // if it is not the red 1 pixel texture we display the texture\n  if (!all(baseColorTex == vec4(1.0, 0.0, 0.0, 1.0))) {\n    color = baseColorTex;\n  }\n\n  var countLights = number_of_lights();\n\n  let ambient_strength = 0.1;\n  let view_dir = normalize(in.camera_position - in.world_position);\n  \n  var result: vec3<f32> = vec3(0., 0., 0.);\n\n  for(var i: u32 = 0; i < countLights; i++) {\n    let light = lights[i];\n    let ambient_color = light.color * light.intensity;\n    \n    let light_dir = normalize(light.position - in.world_position);\n    let half_dir = normalize(view_dir + light_dir);\n    \n    let diffuse_strength = max(dot(in.world_normal, light_dir), 0.0);\n    let diffuse_color = light.color * diffuse_strength;\n\n    let specular_strength = pow(max(dot(in.world_normal, half_dir), 0.0), 32.0);\n    let specular_color = specular_strength * light.color;\n\n    result += (ambient_color + diffuse_color + specular_color) * color.xyz;\n  }\n\n  result /= vec4(f32(countLights)).xyz;\n\n\n // SHADOW\n  let diffuse: f32 = max(dot(normalize(lightPos.xyz), in.world_normal), 0.0);\n  var shadow : f32 = 0.0;\n  // apply Percentage-closer filtering (PCF)\n  // sample nearest 9 texels to smooth result\n  let size = f32(textureDimensions(depthMapTexture).x);\n  for (var y : i32 = -1 ; y <= 1 ; y = y + 1) {\n    for (var x : i32 = -1 ; x <= 1 ; x = x + 1) {\n      let offset = vec2<f32>(f32(x) / size, f32(y) / size);\n      shadow = shadow + textureSampleCompare(\n        depthMapTexture, \n        depthMapSampler,\n        in.shadow_pos.xy + offset, \n        in.shadow_pos.z - 0.005  // apply a small bias to avoid acne\n      );\n    }\n  }\n  shadow = shadow / 9.0;\n  // ambient + diffuse * shadow\n  let lightFactor = min(0.3 + shadow * diffuse, 1.0);\n  result *= lightFactor;\n\n\n  // var shadow: f32 = textureSampleCompare(depthMapTexture, depthMapSampler, in.shadow_pos.xy, in.shadow_pos.z - .01);\n\n  // result = color.xyz;\n  // result = vec3(in.texture, 0.0);\n  // result = in.world_normal;\n\n  // result = vec3(in.face_color);\n  // result = in.picking_color.xyz;\n\n  return vec4(result, 1.0);\n}\n";