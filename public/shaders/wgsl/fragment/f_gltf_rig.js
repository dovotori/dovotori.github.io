export default"\nstruct MaterialUniform {\n  baseColorFactor: vec4f,\n  emissiveFactor: vec3f,\n  roughnessFactor: f32,\n  metallicFactor: f32,\n};\n\n@group(2) @binding(0) var<uniform> material : MaterialUniform;\n@group(2) @binding(1) var baseColorSampler: sampler;\n@group(2) @binding(2) var baseColorTexture: texture_2d<f32>;\n\nstruct PointLight {\n  position: vec3f, \n  color: vec3f, \n  intensity: f32,\n};\n@group(3) @binding(0) var<storage> lights: array<PointLight>;\n\nfn number_of_lights() -> u32 {\n  return arrayLength(&lights);\n}\n\nstruct FragInput {\n  @location(0) world_position: vec3f,\n  @location(1) world_normal: vec3f,\n  @location(2) texture: vec2f,\n  @location(3) camera_position: vec3f,\n  @location(4) debug_color: vec4f,\n};\n\n@fragment fn f_main(in: FragInput) -> @location(0) vec4f {\n  var color = material.baseColorFactor;\n\n  let baseColorTex = textureSample(baseColorTexture, baseColorSampler, in.texture);\n  // if it is not the red 1 pixel texture we display the texture\n  if (!all(baseColorTex == vec4(1.0, 0.0, 0.0, 1.0))) {\n    color = baseColorTex;\n  }\n\n  let countLights = number_of_lights();\n\n  let ambient_strength = 0.1;\n  let view_dir = normalize(in.camera_position - in.world_position);\n  \n  var result: vec3<f32> = vec3(0., 0., 0.);\n\n  for(var i: u32 = 0; i < countLights; i++) {\n    let light = lights[i];\n    let ambient_color = light.color * light.intensity;\n    \n    let light_dir = normalize(light.position - in.world_position);\n    let half_dir = normalize(view_dir + light_dir);\n    \n    let diffuse_strength = max(dot(in.world_normal, light_dir), 0.0);\n    let diffuse_color = light.color * diffuse_strength;\n\n    let specular_strength = pow(max(dot(in.world_normal, half_dir), 0.0), 32.0);\n    let specular_color = specular_strength * light.color;\n\n    result += (ambient_color + diffuse_color + specular_color) * color.xyz;\n  }\n\n  result /= vec4(f32(countLights)).xyz;\n\n  return vec4(result, 1.0);\n  // return vec4(in.debug_color.xyz, 1.0);\n}\n";