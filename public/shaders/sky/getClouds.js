export default"\n#define MIN_HEIGHT 2.0\n#define MAX_HEIGHT 4.5\n\nvec3 sundir = normalize(vec3(1.0, 0.75, 1.0));\n\nfloat planeIntersect(vec3 ro, vec3 rd, float plane) {\n  float h = plane - ro.y;\n  return h / rd.y;\n}\n\nfloat noiseSpe(sampler2D tex, vec3 x, float time, vec2 wind) {\n  vec3 f = fract(x);\n  vec3 p = floor(x);\n  f = f * f * (3.0 - 2.0 * f);\n  \n  p.xz += wind * time;\n  vec2 uv = (p.xz + vec2(37.0, 17.0) * p.y) + f.xz;\n  vec2 rg = texture2D(tex, (uv + 0.5) / 256.0, 0.0).yx;\n  return mix(rg.x, rg.y, f.y);\n}\n\nfloat fractalNoise(sampler2D tex, vec3 p, float time, vec2 wind) {\n  float f = 0.0;\n  // add animation\n  // p = p - vec3(1.0, 1.0, 0.0) * time * 0.1;\n  p = p * 3.0;\n  f += 0.50000 * noiseSpe(tex, p, time, wind); p = 2.0 * p;\n\tf += 0.25000 * noiseSpe(tex, p, time, wind); p = 2.0 * p;\n\tf += 0.12500 * noiseSpe(tex, p, time, wind); p = 2.0 * p;\n\tf += 0.06250 * noiseSpe(tex, p, time, wind); p = 2.0 * p;\n  f += 0.03125 * noiseSpe(tex, p, time, wind);\n  return f;\n}\n\nfloat density(sampler2D tex, vec3 pos, float time, vec2 wind) {    \n  float den = 3.0 * fractalNoise(tex, pos * 0.3, time, wind) - 2.0 + (pos.y - MIN_HEIGHT);\n  float edge = 1.0 - smoothstep(MIN_HEIGHT, MAX_HEIGHT, pos.y);\n  edge *= edge;\n  den *= edge;\n  den = clamp(den, 0.0, 1.0);\n  return den;\n}\n\nvec3 raymarching(\n  sampler2D tex,\n  vec3 ro,\n  vec3 rd,\n  float t,\n  vec3 backColor,\n  float time,\n  vec2 wind\n) {   \n  vec4 sum = vec4(0.0);\n  vec3 pos = ro + rd * t;\n\n  vec3 fix1 = vec3(0.65, 0.7, 0.75);\n  vec3 fix2 = vec3(1.0, 0.6, 0.3);\n\n  for (int i = 0; i < 40; i++) {\n    if (sum.a > 0.99 || \n      pos.y < (MIN_HEIGHT-1.0) || \n      pos.y > (MAX_HEIGHT+1.0)) break;\n    \n    float den = density(tex, pos, time, wind);\n\n    if (den > 0.01) {\n      float dif = clamp((den - density(tex, pos + 0.3 * sundir, time, wind)) / 0.6, 0.0, 1.0);\n      vec3 lin = fix1 * 1.5 + fix2 * dif;        \n      vec4 color = vec4(mix(SKY_COLOR * 1.1, CLOUD_COLOR, den), den);\n      color.rgb *= lin;\n\n      // front to back blending    \n      color.a *= 0.5;\n      color.rgb *= color.a;\n      sum = sum + color * (1.0 - sum.a); \n    }\n    \n    t += max(0.05, 0.02 * t);\n    pos = ro + rd * t;\n  }\n  \n  sum = clamp(sum, 0.0, 1.0);\n  float h = rd.y;\n  sum.rgb = mix(sum.rgb, backColor, exp(-20.0 * h * h));\n  \n  return mix(backColor, sum.xyz, sum.a);\n}\n\nvec3 getClouds(sampler2D tex, vec2 uv, float time, vec3 backColor, vec2 wind) {\n  vec3 color = backColor;\n  vec3 ro = vec3(0.0, 0.0, -2.0); // size\n  vec3 rd = normalize(vec3(uv, 1.5));\n  float dist = planeIntersect(ro, rd, MIN_HEIGHT);\n  if (dist > 0.0) {\n    color = raymarching(tex, ro, rd, dist, color, time, wind);\n  }\n  return color;\n}\n";