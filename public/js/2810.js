"use strict";(self.webpackChunkdovotori_portfolio=self.webpackChunkdovotori_portfolio||[]).push([[2810,552,8735],{72810:(n,t,e)=>{e.r(t),e.d(t,{default:()=>a});var i=e(8735),o=e(20552);const a={vertex:"\nattribute vec3 position;\nattribute vec3 normale;\nattribute vec2 texture;\n\nuniform mat4 projection;\nuniform mat4 model;\nuniform mat4 view;\nuniform mat3 normalMatrix;\nuniform float inverseX;\nuniform float spriteRefSize;\nuniform vec2 spriteUV;\nuniform vec2 spriteGrid;\nuniform vec2 spriteSize;\n\nvarying vec3 fragPosition;\nvarying vec2 fragTexture;\nvarying vec3 fragNormale;\n\n".concat(o.funcMap,"\n\nvoid main() {\n  fragPosition = normalize((view * model * vec4(position, 1.0)).xyz);\n  fragNormale = normalMatrix * normalize(normale);\n\n  vec2 relPos = spriteUV / spriteGrid;\n  vec2 relSize = spriteSize / spriteGrid;\n  float texX = funcMap(\n    texture.x,\n    0.0 + float(inverseX),\n    1.0 - float(inverseX),\n    relPos.x,\n    relPos.x + relSize.x\n  );\n\tfloat texY = funcMap(texture.y, 1.0, 0.0, relPos.y,  relPos.y + relSize.y);\n  fragTexture = vec2(texX, texY);\n  \n  float relW = 1.0 * (spriteSize.x / spriteRefSize);\n  float relH = 1.0 * (spriteSize.y / spriteRefSize);\n\n  float finalX = funcMap(position.x, -1.0, 1.0, -relW, relW);\n  float finalY = funcMap(position.y, -1.0, 1.0, -relH, relH);\n\n  // place le point de pivot en bas\n  // relH - (pivot.y  / spriteRefSize.y) - 1.0\n  float offsetY = relH - 1.0;\n  finalY += offsetY;\n\n  gl_Position = projection * view * model * vec4(finalX, finalY, position.z, 1.0);\n}\n"),fragment:"\nprecision mediump float;\nvarying vec3 fragPosition;\nvarying vec2 fragTexture;\nvarying vec3 fragNormale;\n\n".concat(i.uniformLights,"\n").concat(i.funcLightsColor,"\nuniform sampler2D textureMap;\n\nvoid main() {\n  vec4 ambiant = texture2D(textureMap, fragTexture);\n\n  vec3 color = funcLightsColor(\n    ambiant.xyz,\n    vec3(1.0,1.0,1.0),\n    vec3(1.0,1.0,1.0),\n    fragNormale,\n    fragPosition\n  );\n\n\tgl_FragColor = vec4(color, ambiant.w);\n\t// gl_FragColor = vec4(1.0,0.0,0.0,1.0);\n}\n"),attributes:["position","texture","normale"],uniforms:["projection","model","view","normalMatrix","textureMap","spriteUV","spriteGrid","spriteSize","inverseX","spriteRefSize"].concat((0,i.addLightLocations)())}},20552:(n,t,e)=>{e.r(t),e.d(t,{PI:()=>i,TWO_PI:()=>o,attributeColors:()=>a,funcGradiant:()=>s,funcGrain:()=>c,funcMap:()=>l,varyingColors:()=>r});var i="\n#define PI 3.14159265359\n",o="\n#define TWO_PI 6.28318530718\n",a="\nattribute vec3 ambiant;\nattribute vec3 diffuse;\nattribute vec3 specular;\nattribute float specDensity;\nattribute float opacity;\n",r="\nvarying vec3 fragAmbiant;\nvarying vec3 fragDiffuse;\nvarying vec3 fragSpecular;\nvarying float fragSpecDensity;\nvarying float fragOpacity;\n",l="\nfloat funcMap(float valeur, float minRef, float maxRef, float minDest, float maxDest) {\n  float result = minDest + (valeur - minRef) * (maxDest - minDest) / (maxRef - minRef);\n  if(result > maxDest){ result = maxDest; } else if(result < minDest){ result = minDest; }\n  return result;\n}\n",c="\nvec4 funcGrain(vec2 uv, float time, float strength) {\n  float x = (uv.x + 4.0 ) * (uv.y + 4.0 ) * (time * 10.0);\n  return vec4(mod((mod(x, 13.0) + 1.0) * (mod(x, 123.0) + 1.0), 0.01)-0.005) * strength;\n}\n",s="\n".concat(l,"\nvec4 funcGradiant(vec4 color1, vec4 color2, float start, float end, float uvAxe) {\n  float mixValue = funcMap(uvAxe, start, end, 0.0, 1.0);\n  return mix(color1, color2, mixValue);\n}\n")},8735:(n,t,e)=>{e.r(t),e.d(t,{MAX_LIGHTS:()=>i,addLightLocations:()=>a,funcLightAttenuation:()=>l,funcLightConeAttenuation:()=>r,funcLightsColor:()=>s,funcPhong:()=>c,uniformLights:()=>o});var i=10,o="\n#define MAX_LIGHTS ".concat(i,"\nuniform int numLights;\nuniform struct Light {\n   int type;\n   vec3 position;\n   vec3 ambiant;\n   vec3 diffuse;\n   vec3 specular;\n   float radius;\n   vec3 direction;\n   float strength;\n   float brillance;\n} lights[MAX_LIGHTS];\n"),a=function(){for(var n=[],t=0;t<i;t+=1)n.push("lights[".concat(t,"].type")),n.push("lights[".concat(t,"].position")),n.push("lights[".concat(t,"].ambiant")),n.push("lights[".concat(t,"].diffuse")),n.push("lights[".concat(t,"].specular")),n.push("lights[".concat(t,"].radius")),n.push("lights[".concat(t,"].direction")),n.push("lights[".concat(t,"].brillance")),n.push("lights[".concat(t,"].strength"));return n.push("numLights"),n},r="\nfloat funcLightConeAttenuation(vec3 posLum, vec3 posDirection, vec3 normale, vec3 position) {\n  float intensity = 0.0;\n  float cutoff = 0.9;\n\n  vec3 lightDirection = normalize(posLum - position); \n  vec3 spotDirection = normalize(posDirection);\n\n  // inside the cone ?\n  if (dot(spotDirection, lightDirection) > cutoff) {\n\n    vec3 n = normalize(normale);\n    intensity = max(dot(n, lightDirection), 0.0);\n\n    // if (intensity > 0.0) {\n    // vec3 eye = normalize(DataIn.eye);\n    // vec3 h = normalize(lightDirection + eye);\n    // float intSpec = max(dot(h,n), 0.0);\n    // spec = specular * pow(intSpec, shininess);\n    // }\n  }\n  return intensity;\n}\n",l="\nfloat funcLightAttenuation(vec3 posLum, float radius, vec3 normale, vec3 position) {\n  float cutoff = 0.1;\n  vec3 lightDirection = posLum - position;\n  float distance = length(lightDirection);\n  float d = max(distance - radius, 0.0);\n  lightDirection /= distance;\n  float denom = d / radius + 1.0;\n  float attenuation = 1.0 / (denom * denom);\n    \n  attenuation = (attenuation - cutoff) / (1.0 - cutoff);\n  attenuation = max(attenuation, 0.0);\n\n  float dot = max(dot(lightDirection, normale), 0.0);\n  return attenuation * dot;\n}\n",c="\nvec3 funcPhong(\n  vec3 position,\n  vec3 normale,\n  vec3 ambiant,\n  vec3 diffuse,\n  vec3 specular,\n  vec3 posLum,\n  float brillance\n  ) {\n  vec3 N = normalize(normale);\n  vec3 L = normalize(posLum - position);\n\n  // Lambert's cosine law\n  float lambertian = max(dot(N, L), 0.0);\n\n  float specularValue = 0.0;\n  if(lambertian > 0.0) {\n    vec3 R = reflect(-L, N); // Reflected light vector\n    vec3 V = normalize(-position); // Vector to viewer\n    float specAngle = max(dot(R, V), 0.0);\n    specularValue = pow(specAngle, brillance);\n  }\n\n  return vec3(ambiant * ((lambertian * diffuse) + (specularValue * specular)));\n}\n",s="\n".concat(c,"\n").concat(r,"\n").concat(l,"\nvec3 funcLightsColor(vec3 ambiant, vec3 diffuse, vec3 specular, vec3 normale, vec3 position) {\n  vec3 finalColor = vec3(0.0);\n  for(int i = 0; i < MAX_LIGHTS; i += 1) {\n    if(i < numLights) {\n      vec3 color = funcPhong(\n        position,\n        normale,\n        ambiant * (lights[i].ambiant * lights[i].strength),\n        diffuse * (lights[i].diffuse * lights[i].strength),\n        specular * (lights[i].specular * lights[i].strength),\n        lights[i].position,\n        lights[i].brillance\n      );\n      float att = 1.0;\n      if (lights[i].type == 1) {\n        att = funcLightAttenuation(lights[i].position, lights[i].radius, normale, position);\n      } else if (lights[i].type == 2) {\n        att = funcLightConeAttenuation(lights[i].position, lights[i].direction, normale, position);\n      }\n      color *= att;\n      finalColor += color;\n    }\n  }\n  finalColor /= vec3(numLights);\n  return finalColor;\n}\n")}}]);