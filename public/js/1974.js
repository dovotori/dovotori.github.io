"use strict";(self.webpackChunkdovotori=self.webpackChunkdovotori||[]).push([[1974],{21974(r,e,n){n.r(e),n.d(e,{default:()=>o});const o="\nstruct Uniform {\n  eye: vec4f,\n  viewProjection: mat4x4<f32>,\n};\n\nstruct FragOutput {\n  @location(0) color: vec4f,\n  @location(1) normal: vec4f,\n  @location(2) depth: vec4f,\n};\n\n@binding(1) @group(0) var<uniform> uni: Uniform;\n@binding(2) @group(0) var ourSampler: sampler;\n// @binding(3) @group(0) var ourTexture: texture_2d<f32>;\n@binding(3) @group(0) var ourTexture: texture_cube<f32>;\n\n@fragment\nfn f_main(\n    @location(0) fragUV: vec2<f32>,\n    @location(1) fragPosition: vec4<f32>,\n    @location(2) fragNormal: vec3<f32>,\n    @location(3) worldPosition: vec3<f32>,\n    @location(4) worldNormal: vec3<f32>\n) -> FragOutput {\n // reflect\n    var norm = normalize(worldNormal);\n    var eyeToSurfaceDir = normalize(worldPosition - uni.eye.xyz);\n    var direction = reflect(eyeToSurfaceDir, norm);\n    var tex = textureSample(ourTexture, ourSampler, direction * vec3f(1, 1, -1));\n\n    // var tex = textureSample(ourTexture, ourSampler, fragUV);\n    // var tex = textureSample(ourTexture, ourSampler, fragNormal);\n\n    var out: FragOutput;\n    out.color = tex;\n    out.normal = vec4(fragNormal, 1.0);\n    out.depth = vec4(vec3(fragPosition.z / fragPosition.w), 1.0); // linearize depth\n\n    return out;\n\n    // var specAverage = tex.r * 0.333 + tex.g * 0.333 + tex.b * 0.333;\n    // tex = vec4<f32>(vec3<f32>(specAverage), 1.0);\n    // var rgb = vec3<f32>(0.0, 0.0, 0.0);\n    // return mix(vec4<f32>(rgb, 1.0), tex, 0.5);\n\n    // return vec4<f32>(worldPosition, 1.0);\n    // return vec4<f32>(worldNormal, 1.0);\n    // return vec4<f32>(uni.eye.xyz, 1.0);\n    // return vec4<f32>(fragUV, 0.0, 1.0);\n}\n"}}]);