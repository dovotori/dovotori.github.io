(window.webpackJsonp=window.webpackJsonp||[]).push([[29,95,101],{186:function(e,o,n){"use strict";n.r(o),o.default="\nattribute vec3 position;\nattribute vec2 texture;\nvarying vec2 fragTexture;\nuniform float flipY; // 1 ou -1\n\nvoid main() {\n  fragTexture = texture;\n  gl_Position = vec4(position.x, position.y * flipY, position.z, 1.0);\n}\n"},189:function(e,o,n){"use strict";n.r(o),n.d(o,"funcBlur",(function(){return t})),n.d(o,"funcBlur2",(function(){return r})),n.d(o,"funcBlurDirection",(function(){return c})),n.d(o,"funcBlurOnePass",(function(){return l})),n.d(o,"funcRadialBlur",(function(){return u})),n.d(o,"funcRadialBlur2",(function(){return f}));var t="\nvec4 funcBlur(sampler2D image, vec2 uv, vec2 resolution, vec2 direction) {\n  vec4 color = vec4(0.0);\n  vec2 off1 = vec2(1.411764705882353) * direction;\n  vec2 off2 = vec2(3.2941176470588234) * direction;\n  vec2 off3 = vec2(5.176470588235294) * direction;\n  color += texture2D(image, uv) * 0.1964825501511404;\n  color += texture2D(image, uv + (off1 / resolution)) * 0.2969069646728344;\n  color += texture2D(image, uv - (off1 / resolution)) * 0.2969069646728344;\n  color += texture2D(image, uv + (off2 / resolution)) * 0.09447039785044732;\n  color += texture2D(image, uv - (off2 / resolution)) * 0.09447039785044732;\n  color += texture2D(image, uv + (off3 / resolution)) * 0.010381362401148057;\n  color += texture2D(image, uv - (off3 / resolution)) * 0.010381362401148057;\n  return color;\n}\n",r="\nvec4 funcBlur(sampler2D image, vec2 uv, vec2 resolution, vec2 direction) {\n  vec4 color = vec4(0.0);\n  vec2 off1 = vec2(1.3846153846) * direction;\n  vec2 off2 = vec2(3.2307692308) * direction;\n  color += texture2D(image, uv) * 0.2270270270;\n  color += texture2D(image, uv + (off1 / resolution)) * 0.3162162162;\n  color += texture2D(image, uv - (off1 / resolution)) * 0.3162162162;\n  color += texture2D(image, uv + (off2 / resolution)) * 0.0702702703;\n  color += texture2D(image, uv - (off2 / resolution)) * 0.0702702703;\n  return color;\n}\n",c="\nfloat CalcGauss(float x, float sigma) {\n  float coeff = 1.0 / (2.0 * 3.14157 * sigma);\n  float expon = -(x*x) / (2.0 * sigma);\n  return (coeff*exp(expon));\n}\n\nvec4 funcBlurDirection(sampler2D tex, vec2 uv, vec2 resolution, float direction, float size) {\n  vec4 texCol = texture2D(tex, uv);\n  vec4 gaussCol = texCol;\n  vec2 invSize = 1.0 / resolution;\n  const int width = 4;\n  for ( int i = 1; i <= width; i += 1 ) {\n    vec2 step;\n    if (direction == 0.0) {\n      step = vec2( 0.0, float(i) * invSize.y );\n    } else {\n      step = vec2( float(i) * invSize.x, 0.0 );\n    }\n\n    float weight = CalcGauss(float(i) / float(width), size);\n    texCol = texture2D(tex, uv + step);    \n    gaussCol += vec4( texCol.rgb * weight, weight);\n    texCol = texture2D(tex, uv - step);\n    gaussCol += vec4(texCol.rgb * weight, weight);\n  }\n  gaussCol.rgb /= gaussCol.w;\n  return gaussCol;\n}\n",l="\nvec3 highlights(vec3 pixel, float thres)\n{\n\tfloat val = (pixel.x + pixel.y + pixel.z) / 3.0;\n\treturn pixel * smoothstep(thres - 0.1, thres + 0.1, val);\n}\n\nvec3 samplef(sampler2D tex, vec2 uv) {\n\treturn pow(texture2D(tex, uv).xyz, vec3(2.2));\n}\n\nvec3 hsample(sampler2D tex, vec2 uv) {\n\treturn highlights(samplef(tex, uv), 0.6);\n}\n\nvec3 computeBlur(sampler2D tex, vec2 uv, float offs, vec2 resolution) {\n\tvec4 xoffs = offs * vec4(-2.0, -1.0, 1.0, 2.0) / resolution.x;\n\tvec4 yoffs = offs * vec4(-2.0, -1.0, 1.0, 2.0) / resolution.y;\n\n\tvec3 color = vec3(0.0, 0.0, 0.0);\n\tcolor += hsample(tex, uv + vec2(xoffs.x, yoffs.x)) * 0.00366;\n\tcolor += hsample(tex, uv + vec2(xoffs.y, yoffs.x)) * 0.01465;\n\tcolor += hsample(tex, uv + vec2(    0.0, yoffs.x)) * 0.02564;\n\tcolor += hsample(tex, uv + vec2(xoffs.z, yoffs.x)) * 0.01465;\n\tcolor += hsample(tex, uv + vec2(xoffs.w, yoffs.x)) * 0.00366;\n\t\n\tcolor += hsample(tex, uv + vec2(xoffs.x, yoffs.y)) * 0.01465;\n\tcolor += hsample(tex, uv + vec2(xoffs.y, yoffs.y)) * 0.05861;\n\tcolor += hsample(tex, uv + vec2(    0.0, yoffs.y)) * 0.09524;\n\tcolor += hsample(tex, uv + vec2(xoffs.z, yoffs.y)) * 0.05861;\n\tcolor += hsample(tex, uv + vec2(xoffs.w, yoffs.y)) * 0.01465;\n\t\n\tcolor += hsample(tex, uv + vec2(xoffs.x, 0.0)) * 0.02564;\n\tcolor += hsample(tex, uv + vec2(xoffs.y, 0.0)) * 0.09524;\n\tcolor += hsample(tex, uv + vec2(    0.0, 0.0)) * 0.15018;\n\tcolor += hsample(tex, uv + vec2(xoffs.z, 0.0)) * 0.09524;\n\tcolor += hsample(tex, uv + vec2(xoffs.w, 0.0)) * 0.02564;\n\t\n\tcolor += hsample(tex, uv + vec2(xoffs.x, yoffs.z)) * 0.01465;\n\tcolor += hsample(tex, uv + vec2(xoffs.y, yoffs.z)) * 0.05861;\n\tcolor += hsample(tex, uv + vec2(    0.0, yoffs.z)) * 0.09524;\n\tcolor += hsample(tex, uv + vec2(xoffs.z, yoffs.z)) * 0.05861;\n\tcolor += hsample(tex, uv + vec2(xoffs.w, yoffs.z)) * 0.01465;\n\t\n\tcolor += hsample(tex, uv + vec2(xoffs.x, yoffs.w)) * 0.00366;\n\tcolor += hsample(tex, uv + vec2(xoffs.y, yoffs.w)) * 0.01465;\n\tcolor += hsample(tex, uv + vec2(    0.0, yoffs.w)) * 0.02564;\n\tcolor += hsample(tex, uv + vec2(xoffs.z, yoffs.w)) * 0.01465;\n\tcolor += hsample(tex, uv + vec2(xoffs.w, yoffs.w)) * 0.00366;\n\n\treturn color;\n}\n\nvec3 funcBlur(sampler2D tex, vec2 uv, vec2 resolution) {\n  vec3 color = computeBlur(tex, uv, 2.0, resolution);\n\tcolor += computeBlur(tex, uv, 3.0, resolution);\n\tcolor += computeBlur(tex, uv, 5.0, resolution);\n\tcolor += computeBlur(tex, uv, 7.0, resolution);\n\tcolor /= 4.0;\n  color += samplef(tex, uv);\n  return color;\n}\n",u="\nvec3 funcRadialBlur(sampler2D tex, vec2 uv, vec2 resolution, vec2 center) {\n  // vec2 p = -1.0 + 2.0 * uv / resolution;\n  const float STRENGTH = 0.125;    \n  const int SAMPLES = 64; // multiple of 2\n  \n  vec2 coor = uv / resolution;\n\tvec2 dir = (uv - center) / resolution * vec2(-1.0, 1.0);\n  \n  vec3 color = vec3(0.0);\n  for (int i = 0; i < SAMPLES; i += 2) {\n    color += texture2D(tex, coor + float(i) / float(SAMPLES) * dir * STRENGTH).xyz;\n    color += texture2D(tex, coor + float(i + 1) / float(SAMPLES) * dir * STRENGTH).xyz;\n  }   \n  return color / float(SAMPLES);\n  // return texture2D(tex, coor).xyz;\n}\n",f="\nvec3 deform(sampler2D tex, vec2 p) {\n  vec2 q = sin(vec2(1.1, 1.2) + p);\n\n  float a = atan(q.y, q.x);\n  float r = sqrt(dot(q, q));\n\n  vec2 uv = p * sqrt(1.0 + r * r);\n  uv += sin(vec2(0.0, 0.6) + vec2(1.0, 1.1));\n        \n  return texture2D(tex, uv * 0.3).yxx;\n}\n\n\nvec3 funcRadialBlur2(sampler2D tex, vec2 uv, vec2 resolution) {\n  const int SAMPLES = 64; // multiple of 2\n  vec2 p = uv / resolution;\n\n  vec3  col = vec3(0.0);\n  vec2  d = (vec2(0.5) - p) / float(SAMPLES);\n  float w = 1.0;\n  vec2  s = p;\n  for(int i = 0; i < SAMPLES; i++) {\n    vec3 res = deform(tex, s);\n    col += w * smoothstep(0.0, 1.0, res);\n    w *= 0.99;\n    s += d;\n  }\n  return col * 3.5 / float(SAMPLES);\n}\n"},238:function(e,o,n){"use strict";n.r(o);var t=n(186),r=n(189),c="\nprecision mediump float;\nvarying vec2 fragTexture;\nuniform sampler2D textureMap;\nuniform vec2 resolution;\nuniform float intensity;\n\n".concat(r.funcBlurOnePass,"\n\nvoid main() {\n  vec3 color = funcBlur(textureMap, fragTexture, resolution);\n  // vec3 color = funcRadialBlur(textureMap, fragTexture, vec2(1.0), vec2(0.5, 0.5));\n  // vec3 color = funcRadialBlur2(textureMap, fragTexture, vec2(1.0));\n  gl_FragColor = vec4(color * intensity, 1.0);\n}\n");o.default={vertex:t.default,fragment:c,attributes:["position","texture"],uniforms:["flipY","textureMap","resolution","intensity"]}}}]);