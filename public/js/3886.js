"use strict";(self.webpackChunkdovotori=self.webpackChunkdovotori||[]).push([[2347,3380,3886,4010,4251,4735,5059,6629],{53886:(n,e,t)=>{t.r(e),t.d(e,{default:()=>c});var o=t(54735),i=t(44010),r=t(84251),a=t(2347);const c={vertex:`\nattribute vec3 position;\n\nuniform mat4 projection;\nuniform mat4 model;\nuniform mat4 view;\nuniform mat3 normalMatrix;\n\nuniform vec2 moving;\nuniform float time;\nuniform float waterLevel;\nuniform vec2 gridSize;\nuniform vec3 posEye;\n\nvarying vec3 fragPosition;\nvarying vec3 fragColor;\nvarying vec2 fragTexture;\nvarying vec2 fragMoving;\nvarying vec3 fragNormale;\nvarying vec4 fragClipPosition;\nvarying vec3 fragEyeDir;\n\n${i.funcWave}\n\n#define THRESHOLD 0.005\n\nvoid main() {\n  gl_PointSize = 4.0;\n  vec3 transformed = position;\n\n  vec3 normale = vec3(0.0);\n  if (position.y == 0.0) {\n    vec2 coord = position.xz;\n\n    // for normale\n    vec3 tangent = vec3(1.0, 0.0,0.0);\n\t\tvec3 binormal = vec3(0.0, 0.0, 1.0);\n\n    Wave wave1 = funcWave(\n      coord, 0.1, 0.1, vec2(1.0, 0.0), vec2(time), tangent, binormal\n    );\n    Wave wave2 = funcWave(\n      coord, 0.05, 0.2, vec2(0.0, 1.0), vec2(time), wave1.tangent, wave1.binormal\n    );\n    \n    transformed = wave1.position + wave2.position;\n    transformed *= vec3(0.5, 1.0, 0.5); // rescale wave\n    transformed += vec3(0.0, waterLevel, 0.0); // water level\n    transformed *= vec3(1.0 - THRESHOLD, 1.0, 1.0 - THRESHOLD); // rescale \n    normale = vec3(0.0, 1.0, 0.0); // normalize(cross(wave2.tangent, wave2.binormal));\n  }\n\n  if (position.x == 1.0) {\n    normale = vec3(1.0, 0.0, 0.0);\n  } else if (position.x == -1.0) {\n    normale = vec3(-1.0, 0.0, 0.0);\n  } else if (position.z == 1.0) {\n    normale = vec3(0.0, 0.0, 1.0);\n  } else if (position.z == -1.0) {\n    normale = vec3(0.0, 0.0, -1.0);\n  }\n\n  fragNormale = normalMatrix * normale;\n  fragTexture = position.xz * 0.5 + 0.5;\n  fragPosition = transformed;\n  fragColor = vec3(position.xz, 0.0);\n  fragMoving = moving + time;\n  \n  vec4 worldPos = model * vec4(transformed, 1.0);\n  fragClipPosition = projection * view * worldPos;\n\n  fragEyeDir = posEye - worldPos.xyz;\n\n  gl_Position = fragClipPosition;\n}\n`,fragment:a.default,attributes:["position"],uniforms:["projection","model","view","normalMatrix","moving","gridSize","waterLevel","reflectMap","refractMap","normaleMap","distortionMap","depthMap","posEye","time"].concat(o.fogLocations).concat((0,r.addLightLocations)())}},2347:(n,e,t)=>{t.r(e),t.d(e,{default:()=>r});var o=t(54735),i=t(84251);const r=`\nprecision mediump float;\n\nuniform sampler2D reflectMap;\nuniform sampler2D refractMap;\nuniform sampler2D normaleMap;\nuniform sampler2D distortionMap;\nuniform sampler2D depthMap;\n\n${i.uniformLights}\n${o.fogUniforms}\n\nvarying vec3 fragPosition;\nvarying vec3 fragColor;\nvarying vec2 fragTexture;\nvarying vec3 fragNormale;\nvarying vec4 fragClipPosition;\nvarying vec3 fragEyeDir;\nvarying vec2 fragMoving;\n\n${o.getFogAmount}\n${i.funcLightsColor}\n\nvoid main() {\n  vec3 waterColor = vec3(0.5, 0.6, 0.75);\n\n  vec2 tilingCoor = fragMoving + fragTexture * 4.0;\n\n  float correction = 0.205; // ?? coor to low\n  vec3 ndc = (fragClipPosition.xyz / fragClipPosition.w) / 2.0 + 0.5;\n  vec2 reflectCoor = vec2(ndc.x, 1.0 - ndc.y + correction);\n  vec2 refractCoor = vec2(ndc.x, ndc.y);\n\n  float fresnel = pow(dot(normalize(fragEyeDir), normalize(fragNormale)), 2.0);\n\n  vec2 distortionCoor1 = vec2(tilingCoor.x + fragMoving.x, tilingCoor.y);\n  vec2 distortionCoor2 = vec2(tilingCoor.x, tilingCoor.y + fragMoving.y);\n  vec2 distortion1 = texture2D(distortionMap, distortionCoor1).rg * 2.0 - 1.0;\n  vec2 distortion2 = texture2D(distortionMap, distortionCoor2).rg * 2.0 - 1.0;\n  vec2 distortion = distortion1 + distortion2;\n  distortion *= 0.004; // distorsion strength\n\n  reflectCoor += distortion;\n  refractCoor += distortion;\n\n  reflectCoor = clamp(reflectCoor, vec2(0.0001), vec2(0.9999));\n  refractCoor = clamp(refractCoor, vec2(0.0001), vec2(0.9999));\n\n  vec4 reflectColor = texture2D(reflectMap, reflectCoor);\n  vec4 refractColor = texture2D(refractMap, refractCoor);\n\n  vec2 normCoor = (tilingCoor * 2.0) + (fragMoving * 0.2);\n\n  vec3 normale = texture2D(normaleMap, normCoor).xyz;\n  normale = normalize(normale);\n\n  if (fragNormale.y <= 0.5) {\n    normale = fragNormale;\n  }\n\n  vec3 lightColor = funcLightsColor(\n    waterColor,\n    waterColor,\n    vec3(1.0),\n    normale,\n    fragPosition\n  );\n\n  vec4 color = mix(refractColor, reflectColor, fresnel);\n  float fogAmount = getFogAmount(fragClipPosition.xyz, fogStart, fogEnd);\n  vec4 finalColor = color + vec4(lightColor, 0.0); // spec light how to add ?\n  finalColor = mix(finalColor, fogColor, fogAmount);\n  // finalColor = vec4(normale, 1.0);\n\n  float depth = texture2D(depthMap, ndc.xy).r;\n\n  gl_FragColor = finalColor;\n  \n}\n`},54735:(n,e,t)=>{t.r(e),t.d(e,{fogFactorExp2:()=>o,fogFactorLinear:()=>i,fogLocations:()=>c,fogUniforms:()=>a,getFogAmount:()=>r});const o="\nfloat fogFactorExp2(\n  const float dist,\n  const float density\n) {\n  const float LOG2 = -1.442695;\n  float d = density * dist;\n  return 1.0 - clamp(exp2(d * d * LOG2), 0.0, 1.0);\n}\n",i="\nfloat fogFactorLinear(\n  const float dist,\n  const float start,\n  const float end\n) {\n  return 1.0 - clamp((end - dist) / (end - start), 0.0, 1.0);\n}\n",r=`\n${i}\nfloat getFogAmount(vec3 position, float start, float end) {\n  float fogDistance = length(position);\n  return fogFactorLinear(fogDistance, start, end);\n}\n`,a="\nuniform vec4 fogColor;\nuniform float fogStart;\nuniform float fogEnd;\n",c=["fogStart","fogEnd","fogColor"]},75059:(n,e,t)=>{t.r(e),t.d(e,{PI:()=>o,TWO_PI:()=>i,attributeColors:()=>r,funcGradiant:()=>s,funcGrain:()=>l,funcMap:()=>c,varyingColors:()=>a});const o="\n#define PI 3.14159265359\n",i="\n#define TWO_PI 6.28318530718\n",r="\nattribute vec3 ambiant;\nattribute vec3 diffuse;\nattribute vec3 specular;\nattribute float specDensity;\nattribute float opacity;\n",a="\nvarying vec3 fragAmbiant;\nvarying vec3 fragDiffuse;\nvarying vec3 fragSpecular;\nvarying float fragSpecDensity;\nvarying float fragOpacity;\n",c="\nfloat funcMap(float valeur, float minRef, float maxRef, float minDest, float maxDest) {\n  float result = minDest + (valeur - minRef) * (maxDest - minDest) / (maxRef - minRef);\n  if(result > maxDest){ result = maxDest; } else if(result < minDest){ result = minDest; }\n  return result;\n}\n",l="\nvec4 funcGrain(vec2 uv, float time, float strength) {\n  float x = (uv.x + 4.0 ) * (uv.y + 4.0 ) * (time * 10.0);\n  return vec4(mod((mod(x, 13.0) + 1.0) * (mod(x, 123.0) + 1.0), 0.01)-0.005) * strength;\n}\n",s=`\n${c}\nvec4 funcGradiant(vec4 color1, vec4 color2, float start, float end, float uvAxe) {\n  float mixValue = funcMap(uvAxe, start, end, 0.0, 1.0);\n  return mix(color1, color2, mixValue);\n}\n`},84251:(n,e,t)=>{t.r(e),t.d(e,{MAX_LIGHTS:()=>o,addLightLocations:()=>r,funcLightAttenuation:()=>c,funcLightConeAttenuation:()=>a,funcLightsColor:()=>s,funcPhong:()=>l,uniformLights:()=>i});const o=10,i=`\n#define MAX_LIGHTS ${o}\nuniform int numLights;\nuniform struct Light {\n   int type;\n   vec3 position;\n   vec3 ambiant;\n   vec3 diffuse;\n   vec3 specular;\n   float radius;\n   vec3 direction;\n   float strength;\n   float brillance;\n} lights[MAX_LIGHTS];\n`,r=()=>{const n=[];for(let e=0;e<o;e+=1)n.push(`lights[${e}].type`),n.push(`lights[${e}].position`),n.push(`lights[${e}].ambiant`),n.push(`lights[${e}].diffuse`),n.push(`lights[${e}].specular`),n.push(`lights[${e}].radius`),n.push(`lights[${e}].direction`),n.push(`lights[${e}].brillance`),n.push(`lights[${e}].strength`);return n.push("numLights"),n},a="\nfloat funcLightConeAttenuation(vec3 posLum, vec3 posDirection, vec3 normale, vec3 position) {\n  float intensity = 0.0;\n  float cutoff = 0.9;\n\n  vec3 lightDirection = normalize(posLum - position); \n  vec3 spotDirection = normalize(posDirection);\n\n  // inside the cone ?\n  if (dot(spotDirection, lightDirection) > cutoff) {\n\n    vec3 n = normalize(normale);\n    intensity = max(dot(n, lightDirection), 0.0);\n\n    // if (intensity > 0.0) {\n    // vec3 eye = normalize(DataIn.eye);\n    // vec3 h = normalize(lightDirection + eye);\n    // float intSpec = max(dot(h,n), 0.0);\n    // spec = specular * pow(intSpec, shininess);\n    // }\n  }\n  return intensity;\n}\n",c="\nfloat funcLightAttenuation(vec3 posLum, float radius, vec3 normale, vec3 position) {\n  float cutoff = 0.1;\n  vec3 lightDirection = posLum - position;\n  float distance = length(lightDirection);\n  float d = max(distance - radius, 0.0);\n  lightDirection /= distance;\n  float denom = d / radius + 1.0;\n  float attenuation = 1.0 / (denom * denom);\n    \n  attenuation = (attenuation - cutoff) / (1.0 - cutoff);\n  attenuation = max(attenuation, 0.0);\n\n  float dot = max(dot(lightDirection, normale), 0.0);\n  return attenuation * dot;\n}\n",l="\nvec3 funcPhong(\n  vec3 position,\n  vec3 normale,\n  vec3 ambiant,\n  vec3 diffuse,\n  vec3 specular,\n  vec3 posLum,\n  float brillance\n  ) {\n  vec3 N = normalize(normale);\n  vec3 L = normalize(posLum - position);\n\n  // Lambert's cosine law\n  float lambertian = max(dot(N, L), 0.0);\n\n  float specularValue = 0.0;\n  if(lambertian > 0.0) {\n    vec3 R = reflect(-L, N); // Reflected light vector\n    vec3 V = normalize(-position); // Vector to viewer\n    float specAngle = max(dot(R, V), 0.0);\n    specularValue = pow(specAngle, brillance);\n  }\n\n  return vec3(ambiant * ((lambertian * diffuse) + (specularValue * specular)));\n}\n",s=`\n${l}\n${a}\n${c}\nvec3 funcLightsColor(vec3 ambiant, vec3 diffuse, vec3 specular, vec3 normale, vec3 position) {\n  vec3 finalColor = vec3(0.0);\n  for(int i = 0; i < MAX_LIGHTS; i += 1) {\n    if(i < numLights) {\n      vec3 color = funcPhong(\n        position,\n        normale,\n        ambiant * (lights[i].ambiant * lights[i].strength),\n        diffuse * (lights[i].diffuse * lights[i].strength),\n        specular * (lights[i].specular * lights[i].strength),\n        lights[i].position,\n        lights[i].brillance\n      );\n      float att = 1.0;\n      if (lights[i].type == 1) {\n        att = funcLightAttenuation(lights[i].position, lights[i].radius, normale, position);\n      } else if (lights[i].type == 2) {\n        att = funcLightConeAttenuation(lights[i].position, lights[i].direction, normale, position);\n      }\n      color *= att;\n      finalColor += color;\n    }\n  }\n  finalColor /= vec3(numLights);\n  return finalColor;\n}\n`},86629:(n,e,t)=>{t.r(e),t.d(e,{anothorNoise1D:()=>l,anothorNoise2D:()=>s,funcNoise:()=>r,funcPnoise:()=>a,funcSnoise:()=>c});var o=t(3380),i=t(75059);const r=`\n${o.funcRand}\nfloat noise(vec2 n) {\n\tconst vec2 d = vec2(0.0, 1.0);\n  vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\treturn mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n`,a=`\n${i.PI}\n${o.funcRand}\nfloat noise(vec2 p, float freq) {\n\tfloat unit = freq;\n\tvec2 ij = floor(p / unit);\n\tvec2 xy = mod(p, unit) / unit;\n\t//xy = 3. * xy * xy -2. * xy * xy * xy;\n\txy = .5 * (1. - cos(PI * xy));\n\tfloat a = rand((ij + vec2(0.,0.)));\n\tfloat b = rand((ij + vec2(1.,0.)));\n\tfloat c = rand((ij + vec2(0.,1.)));\n\tfloat d = rand((ij + vec2(1.,1.)));\n\tfloat x1 = mix(a, b, xy.x);\n\tfloat x2 = mix(c, d, xy.x);\n\treturn mix(x1, x2, xy.y);\n}\n\nfloat pnoise(vec2 p){\n\tfloat persistance = .5;\n\tfloat n = 0.;\n\tfloat normK = 0.;\n\tfloat f = 4.;\n\tfloat amp = 1.;\n\tint iCount = 0;\n\tfor (int i = 0; i<50; i++){\n\t\tn+=amp*noise(p, f);\n\t\tf*=2.;\n\t\tnormK+=amp;\n\t\tamp*=persistance;\n\t\tiCount++;\n\t}\n\tfloat nf = n/normK;\n\treturn nf*nf*nf*nf;\n}\n`,c="\n//\tSimplex 3D Noise \n//\tby Ian McEwan, Ashima Arts\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nfloat snoise(vec3 v){ \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //  x0 = x0 - 0. + 0.0 * C \n  vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n  vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n  vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n// Permutations\n  i = mod(i, 289.0 ); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients\n// ( N*N points uniformly over a square, mapped onto an octahedron.)\n  float n_ = 1.0/7.0; // N=7\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}\n",l="\nfloat hash(float p) {\n  p = fract(p * 0.011);\n  p *= p + 7.5;\n  p *= p + p;\n  return fract(p);\n}\n\nfloat noise(float x) {\n  float i = floor(x);\n  float f = fract(x);\n  float u = f * f * (3.0 - 2.0 * f);\n  return mix(hash(i), hash(i + 1.0), u);\n}\n",s="\nfloat hash(vec2 p) {\n  vec3 p3 = fract(vec3(p.xyx) * 0.13);\n  p3 += dot(p3, p3.yzx + 3.333);\n  return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat noise(vec2 x) {\n  vec2 i = floor(x);\n  vec2 f = fract(x);\n\n\t// Four corners in 2D of a tile\n\tfloat a = hash(i);\n  float b = hash(i + vec2(1.0, 0.0));\n  float c = hash(i + vec2(0.0, 1.0));\n  float d = hash(i + vec2(1.0, 1.0));\n\n  // Simple 2D lerp using smoothstep envelope between the values.\n\t// return vec3(mix(mix(a, b, smoothstep(0.0, 1.0, f.x)),\n\t//\t\t\tmix(c, d, smoothstep(0.0, 1.0, f.x)),\n\t//\t\t\tsmoothstep(0.0, 1.0, f.y)));\n\n\t// Same code, with the clamps in smoothstep and common subexpressions\n\t// optimized away.\n  vec2 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n"},3380:(n,e,t)=>{t.r(e),t.d(e,{funcRand:()=>o,funcRandFloat:()=>r,funcRandRange:()=>i,randRGBA:()=>a});const o="\n// between 0 - 1\nfloat rand(vec2 n) {\n  return fract(sin(dot(n.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n",i=`\n${o}\nfloat randomRange(vec2 seed, float min, float max) {\n\treturn min + rand(seed) * (max - min);\n}\n`,r="\nfloat randFloat(float n){ return fract(sin(n) * 43758.5453123); }\n",a="\n#define PHI 1.61803398874989484820459\n\nfloat goldNoise(vec2 xy, float seed) {\n  return fract(tan(distance(xy * PHI, xy) * seed) * xy.x);\n}\n\nvec4 randRGBA (vec2 nn, float time) {\n  vec2 n = nn; \n  return vec4(\n    goldNoise(n, fract(time) + 1.0), // r\n    goldNoise(n, fract(time) + 2.0), // g\n    goldNoise(n, fract(time) + 3.0), // b\n    1.0);\n}\n"},44010:(n,e,t)=>{t.r(e),t.d(e,{funcWave:()=>c,getNaturalHeight:()=>r,getNormale:()=>l,locations:()=>a});var o=t(86629),i=t(75059);const r=`\n${o.anothorNoise2D}\n\n#define NB_OCTAVES 10\nuniform float lacunarity; // frequency of noise octave\nuniform float persistance; // influence of noise octave\n\nuniform vec2 moving;\nuniform vec2 gridSize;\n\nfloat getNaturalHeight(vec2 coor) {\n  float result = 0.0;\n  float allAmpli = 0.0;\n  for(int i = 0; i < NB_OCTAVES; i += 1) {\n    float frequency = pow(lacunarity, float(i));\n    float amplitude = pow(persistance, float(i));\n    result += noise(coor * frequency) * amplitude;\n    allAmpli += amplitude;\n  }\n  return result / allAmpli;\n}`,a=["octaves","lacunarity","persistance","moving","gridSize"],c=`\n${i.PI}\n\nstruct Wave {\n  vec3 position;\n\tvec3 tangent;\n\tvec3 binormal;\n};\n\nWave funcWave(\n  vec2 uv,\n  float steepness, // raideur -> steepness prevent looping (replace amplitude) entre 0 et 1\n  float wavelength,\n  vec2 direction,\n  vec2 time,\n  vec3 tangent,\n  vec3 binormal\n) {\n  vec2 D = normalize(direction);\n\tfloat K = 2.0 * PI / wavelength;\n\tfloat C = sqrt(9.8 / K);\n  float F = K * (dot(D, uv) - C * time.y);\n\n\tfloat A = steepness / K;\n\n\tvec3 p = vec3(uv.x, 0.0, uv.y);\n\tp.x += D.x * (A * cos(F));\n\tp.y = A * sin(F);\n\tp.z += D.y * (A * cos(F));\n\n  // on en profite pour update tangent et binormal\n  tangent += vec3(\n    -1.0 - D.x * D.x * (steepness * sin(F)),\n    D.x * (steepness * cos(F)),\n    -D.x * D.y * (steepness * sin(F))\n  );\n\n  binormal += vec3(\n    -D.x * D.y * (steepness * sin(F)),\n    D.y * (steepness * cos(F)),\n    - D.y * D.y * (steepness * sin(F))\n  );\n\n\treturn Wave(\n    p,\n    tangent,\n    binormal\n  );\n}\n`,l="\nvec3 computeNormale(vec3 p0, vec3 p1, vec3 p2) {\n  return cross(p1 - p0, p2 - p0);\n}\n\nvec3 roundNormale(vec3 position, vec2 moving) {\n  vec2 betweenPoints = 2.0 / gridSize;\n\n  vec2 coordP0 = position.xz + vec2(betweenPoints.x, 0.0) + moving;\n  vec2 coordP1 = position.xz + vec2(betweenPoints.x, 0.0) + moving;\n  vec2 coordP2 = position.xz + vec2(0.0, betweenPoints.y) + moving;\n  \n  vec3 p0 = vec3(0.0, position.y, 0.0);\n  vec3 p1 = vec3(betweenPoints.x, getNaturalHeight(coordP1), 0.0);\n  vec3 p2 = vec3(0.0, getNaturalHeight(coordP2), betweenPoints.y);\n\n  return normalize(computeNormale(p0, p2, p1));\n}\n\nvec3 getNormale(vec3 position, vec3 tranformed) {\n  vec3 normale = vec3(0.0);\n  if (position.y == 0.0) {\n    normale = roundNormale(tranformed, moving);\n  }\n  if (position.x == 1.0) {\n    normale = vec3(1.0 ,0.0, 0.0);\n  } else if (position.x == -1.0) {\n    normale = vec3(-1.0 ,0.0, 0.0);\n  } else if (position.z == 1.0) {\n    normale = vec3(0.0 ,0.0, 1.0);\n  } else if (position.z == -1.0) {\n    normale = vec3(0.0 ,0.0, -1.0);\n  }\n  return normale;\n}\n"}}]);