"use strict";(self.webpackChunkdovotori=self.webpackChunkdovotori||[]).push([[1014,7598],{51014(n,i,e){e.r(i),e.d(i,{default:()=>t});const t="\nattribute vec3 position;\nattribute vec2 texture;\nvarying vec2 fragTexture;\nuniform float flipY; // 1 ou -1\n\nvoid main() {\n  fragTexture = texture;\n  gl_Position = vec4(position.x, position.y * flipY, position.z, 1.0);\n}\n"},87598(n,i,e){e.r(i),e.d(i,{default:()=>t});const t={vertex:e(51014).default,fragment:"\nprecision mediump float;\n\nvarying vec2 fragTexture;\nuniform sampler2D textureMap;\nuniform vec2 resolution;\n\n#define PASS 7\n\nvec3 kuwahara() {\n  vec2 radius = vec2(0.001); // to adapt\n  vec2 uv = fragTexture;\n  float n = float((PASS + 1) * (PASS + 1));\n  int i; \n  int j;\n  vec3 m0 = vec3(0.0);\n  vec3 m1 = vec3(0.0);\n  vec3 m2 = vec3(0.0);\n  vec3 m3 = vec3(0.0);\n  vec3 s0 = vec3(0.0);\n  vec3 s1 = vec3(0.0);\n  vec3 s2 = vec3(0.0);\n  vec3 s3 = vec3(0.0);\n  vec3 c;\n\n  for (int j = -PASS; j <= 0; ++j)  {\n    for (int i = -PASS; i <= 0; ++i)  {\n      c = texture2D(textureMap, uv + vec2(i,j) * radius).rgb;\n      m0 += c;\n      s0 += c * c;\n    }\n  }\n\n  for (int j = -PASS; j <= 0; ++j)  {\n    for (int i = 0; i <= PASS; ++i)  {\n      c = texture2D(textureMap, uv + vec2(i,j) * radius).rgb;\n      m1 += c;\n      s1 += c * c;\n    }\n  }\n\n  for (int j = 0; j <= PASS; ++j)  {\n    for (int i = 0; i <= PASS; ++i)  {\n      c = texture2D(textureMap, uv + vec2(i,j) * radius).rgb;\n      m2 += c;\n      s2 += c * c;\n    }\n  }\n\n  for (int j = 0; j <= PASS; ++j)  {\n    for (int i = -PASS; i <= 0; ++i)  {\n      c = texture2D(textureMap, uv + vec2(i,j) * radius).rgb;\n      m3 += c;\n      s3 += c * c;\n    }\n  }\n\n  vec3 color = vec3(1.0);\n\n  float min_sigma2 = 1e+2;\n  m0 /= n;\n  s0 = abs(s0 / n - m0 * m0);\n\n  float sigma2 = s0.r + s0.g + s0.b;\n  if (sigma2 < min_sigma2) {\n    min_sigma2 = sigma2;\n    color = m0;\n  }\n\n  m1 /= n;\n  s1 = abs(s1 / n - m1 * m1);\n\n  sigma2 = s1.r + s1.g + s1.b;\n  if (sigma2 < min_sigma2) {\n    min_sigma2 = sigma2;\n    color = m1;\n  }\n\n  m2 /= n;\n  s2 = abs(s2 / n - m2 * m2);\n\n  sigma2 = s2.r + s2.g + s2.b;\n  if (sigma2 < min_sigma2) {\n    min_sigma2 = sigma2;\n    color = m2;\n  }\n\n  m3 /= n;\n  s3 = abs(s3 / n - m3 * m3);\n\n  sigma2 = s3.r + s3.g + s3.b;\n  if (sigma2 < min_sigma2) {\n    min_sigma2 = sigma2;\n    color = m3;\n  }\n  return color;\n}\n\nvoid main() {\n  float alpha = texture2D(textureMap, fragTexture).w;\n  gl_FragColor = vec4(kuwahara(), alpha);\n}",attributes:["position","texture"],uniforms:["flipY","textureMap","resolution"]}}}]);