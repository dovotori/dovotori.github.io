"use strict";(self.webpackChunkdovotori_portfolio=self.webpackChunkdovotori_portfolio||[]).push([[3477,7719],{57719:(e,n,o)=>{o.r(n),o.d(n,{default:()=>t});const t="\nattribute vec3 position;\nattribute vec2 texture;\nvarying vec2 fragTexture;\nuniform float flipY; // 1 ou -1\n\nvoid main() {\n  fragTexture = texture;\n  gl_Position = vec4(position.x, position.y * flipY, position.z, 1.0);\n}\n"},63477:(e,n,o)=>{o.r(n),o.d(n,{NUM_SAMPLES:()=>r,NUM_NOISE:()=>i,default:()=>s});var t=o(57719),r=64,i=4,a="\nprecision mediump float;\n#define NUM_SAMPLES ".concat(r,"\n#define NUM_NOISE ").concat(i,"\n\nuniform vec3 samples[NUM_SAMPLES];\nuniform mat4 projection;\nuniform mat4 inverseProjection;\nuniform mat4 inverseView;\nuniform vec2 resolution;\nuniform float radius;\nuniform sampler2D positionMap;\nuniform sampler2D normalMap;\nuniform sampler2D noiseMap;\nuniform sampler2D depthMap;\n\nvarying vec2 fragTexture;\n\n// vec3 getPositionFromDepth(vec2 uv) {\n//   float x = uv.x * 2.0 - 1.0;\n//   float y = uv.y * 2.0 - 1.0;\n//   float z = texture2D(depthMap, uv).r * 2.0 - 1.0;  \n//   vec4 projectedPos = vec4(x, y, z, 1.0) * inverseProjection;\n//   return projectedPos.xyz / projectedPos.w;  \n// }\n\n// vec3 getPositionFromDepth(vec2 uv) {\n//   float z = texture2D(depthMap, uv).r;\n//   vec3 position = vec3(uv, z) * 2.0 - 1.0;\n//   vec4 clipSpacePosition = vec4(position, 1.0);\n//   vec4 viewSpacePosition = inverseProjection * clipSpacePosition;\n//   viewSpacePosition /= viewSpacePosition.w;\n//   return viewSpacePosition.xyz;\n//   vec4 worldSpacePosition = inverseView * viewSpacePosition;\n//   return worldSpacePosition.xyz;\n// }\n\nfloat funcSsao(vec2 uv) {\n  vec3 position = texture2D(positionMap, uv).xyz * 2.0 - 1.0;\n  vec3 normal = normalize(texture2D(normalMap, uv).xyz * 2.0 - 1.0);\n\n  vec2 noiseScale = resolution / float(NUM_NOISE);\n  vec3 random = texture2D(noiseMap, uv * noiseScale).xyz * 2.0 - 1.0;\n  vec3 tangent = normalize(random - normal * dot(random, normal));\n  vec3 bitangent = cross(normal, tangent);\n  mat3 tbn = mat3(tangent, bitangent, normal); // orientation matrix\n\n  float occlusion = 0.0;\n  for (int i = 0; i < NUM_SAMPLES; ++i) {\n    vec3 sample = tbn * samples[i];\n    sample = position + sample * radius;\n    \n    vec4 offset = vec4(sample, 1.0);\n    offset = projection * offset;\n    offset.xy /= offset.w;\n    offset.xy = offset.xy * 0.5 + 0.5;\n    \n    float sampleDepth = texture2D(positionMap, offset.xy).z * 2.0 - 1.0;\n    \n    // float rangeCheck = abs(position.z - sampleDepth) < radius ? 1.0 : 0.0;\n    occlusion += (sampleDepth <= sample.z ? 1.0 : 0.0);\n  }\n  return 1.0 - (occlusion / float(NUM_SAMPLES));\n}\n\nvoid main() {\n  gl_FragColor = vec4(vec3(funcSsao(fragTexture)), 1.0);\n  \n  // gl_FragColor = vec4(vec3(texture2D(positionMap, fragTexture).z), 1.0);\n  // gl_FragColor = vec4(getPositionFromDepth(fragTexture), 1.0);\n  // gl_FragColor = vec4(vec3(getPositionFromDepth(fragTexture).z), 1.0);\n  // gl_FragColor = texture2D(positionMap, fragTexture);\n  // gl_FragColor = texture2D(normalMap, fragTexture);\n  // gl_FragColor = texture2D(depthMap, fragTexture);\n  // gl_FragColor = vec4(vec3(texture2D(depthMap, fragTexture).r * 2.0 - 1.0), 1.0);\n\n  // vec2 noiseScale = resolution / 4.0;\n  // vec3 random = texture2D(noiseMap, fragTexture).xyz * 2.0 - 1.0;\n  // gl_FragColor = vec4(random, 1.0);\n  \n  // gl_FragColor = vec4(vec3(samples[0].z), 1.0);\n}\n");const s={vertex:t.default,fragment:a,attributes:["position","texture"],uniforms:["flipY","positionMap","normalMap","depthMap","noiseMap","projection","inverseProjection","inverseView","radius","resolution"].concat(Array.from(Array(r).keys()).map((function(e){return"samples[".concat(e,"]")})))}}}]);