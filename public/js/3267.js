"use strict";(self.webpackChunkdovotori=self.webpackChunkdovotori||[]).push([[3267],{63267(n,e,r){r.r(e),r.d(e,{default:()=>o});const o="\n@group(0) @binding(0) var mySampler: sampler;\n@group(0) @binding(1) var myTexture: texture_2d<f32>;\n@group(0) @binding(2) var<uniform> threshold: f32;\n@group(0) @binding(3) var<uniform> uGlow_ThresholdKnee: f32;\n\nstruct VertexOutput {\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv: vec2<f32>,\n};\n\n@vertex\nfn vs_main(@builtin(vertex_index) vertexIndex: u32) -> VertexOutput {\n  var pos = array<vec2<f32>, 3>(\n    vec2f(-1.0, -1.0),\n    vec2f(-1.0,  3.0),\n    vec2f( 3.0, -1.0),\n  );\n\n  var uv = array<vec2<f32>, 3>(\n    vec2<f32>(0.0, 1.0),\n    vec2<f32>(0.0,  -1.0),\n    vec2<f32>(2.0,  1.0),\n  );\n\n  var output: VertexOutput;\n  output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);\n  output.uv = uv[vertexIndex];\n  return output;\n}\n\n@fragment\nfn fs_main(@location(0) uv: vec2<f32>) -> @location(0) vec4<f32> {\n  let color = textureSample(myTexture, mySampler, uv);\n  let brightness = max(max(color.r, color.g), color.b);\n\n  // Soft-knee threshold using smoothstep\n  let bloomFactor = smoothstep(threshold - uGlow_ThresholdKnee, threshold + uGlow_ThresholdKnee, brightness);\n  // return vec4<f32>(color.rgb * bloomFactor, color.a * bloomFactor);\n  // return vec4<f32>(uGlow_ThresholdKnee,0.0,0.0,1.0); // debug\n\n  if (brightness > 0.5) {\n    return vec4<f32>(1.0, 1.0, 1.0, 1.0);\n  } else {\n    return vec4<f32>(0.0, 0.0, 0.0, 1.0);\n  } \n}\n"}}]);