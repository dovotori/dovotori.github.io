"use strict";(self.webpackChunkdovotori=self.webpackChunkdovotori||[]).push([[7416],{37416(o,n,t){t.r(n),t.d(n,{default:()=>i});const i="\nstruct Uniform {\n  eye: vec4f,\n  viewProjection: mat4x4<f32>,\n};\n\nstruct VertexOutput {\n    @builtin(position) Position : vec4<f32>,\n    @location(0) fragUV : vec2<f32>,\n    @location(1) fragPosition: vec4<f32>,\n    @location(2) fragNormal: vec3<f32>,\n    @location(3) worldPosition: vec3<f32>,\n    @location(4) worldNormal: vec3<f32>\n};\n\n@binding(0) @group(0) var<storage, read> model : array<mat4x4<f32>>;\n@binding(1) @group(0) var<uniform> uni: Uniform;\n\n@vertex\nfn v_main(\n    @builtin(instance_index) index : u32,\n    @location(0) position : vec4<f32>,\n    @location(1) normal : vec3<f32>,\n    @location(2) uv : vec2<f32>\n) -> VertexOutput {\n    var output : VertexOutput;\n    output.Position = uni.viewProjection * model[index] * position;\n    output.fragPosition = 0.5 * (position + vec4<f32>(1.0, 1.0, 1.0, 1.0));\n    // output.fragNormal = normalize(position.xyz); // for cube map\n    output.fragNormal = normalize(normal.xyz); // for cube map\n    output.worldPosition = (model[index] * position).xyz;\n    output.worldNormal = (model[index] * vec4f(normal, 0)).xyz;\n    output.fragUV = uv;\n    return output;\n}"}}]);