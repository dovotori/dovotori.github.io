"use strict";(self.webpackChunkdovotori=self.webpackChunkdovotori||[]).push([[2347,4251,4735],{2347(n,o,t){t.r(o),t.d(o,{default:()=>r});var i=t(54735),e=t(84251);const r=`\nprecision mediump float;\n\nuniform sampler2D reflectMap;\nuniform sampler2D refractMap;\nuniform sampler2D normaleMap;\nuniform sampler2D distortionMap;\nuniform sampler2D depthMap;\n\n${e.uniformLights}\n${i.fogUniforms}\n\nvarying vec3 fragPosition;\nvarying vec3 fragColor;\nvarying vec2 fragTexture;\nvarying vec3 fragNormale;\nvarying vec4 fragClipPosition;\nvarying vec3 fragEyeDir;\nvarying vec2 fragMoving;\n\n${i.getFogAmount}\n${e.funcLightsColor}\n\nvoid main() {\n  vec3 waterColor = vec3(0.5, 0.6, 0.75);\n\n  vec2 tilingCoor = fragMoving + fragTexture * 4.0;\n\n  float correction = 0.205; // ?? coor to low\n  vec3 ndc = (fragClipPosition.xyz / fragClipPosition.w) / 2.0 + 0.5;\n  vec2 reflectCoor = vec2(ndc.x, 1.0 - ndc.y + correction);\n  vec2 refractCoor = vec2(ndc.x, ndc.y);\n\n  float fresnel = pow(dot(normalize(fragEyeDir), normalize(fragNormale)), 2.0);\n\n  vec2 distortionCoor1 = vec2(tilingCoor.x + fragMoving.x, tilingCoor.y);\n  vec2 distortionCoor2 = vec2(tilingCoor.x, tilingCoor.y + fragMoving.y);\n  vec2 distortion1 = texture2D(distortionMap, distortionCoor1).rg * 2.0 - 1.0;\n  vec2 distortion2 = texture2D(distortionMap, distortionCoor2).rg * 2.0 - 1.0;\n  vec2 distortion = distortion1 + distortion2;\n  distortion *= 0.004; // distorsion strength\n\n  reflectCoor += distortion;\n  refractCoor += distortion;\n\n  reflectCoor = clamp(reflectCoor, vec2(0.0001), vec2(0.9999));\n  refractCoor = clamp(refractCoor, vec2(0.0001), vec2(0.9999));\n\n  vec4 reflectColor = texture2D(reflectMap, reflectCoor);\n  vec4 refractColor = texture2D(refractMap, refractCoor);\n\n  vec2 normCoor = (tilingCoor * 2.0) + (fragMoving * 0.2);\n\n  vec3 normale = texture2D(normaleMap, normCoor).xyz;\n  normale = normalize(normale);\n\n  if (fragNormale.y <= 0.5) {\n    normale = fragNormale;\n  }\n\n  vec3 lightColor = funcLightsColor(\n    waterColor,\n    waterColor,\n    vec3(1.0),\n    normale,\n    fragPosition\n  );\n\n  vec4 color = mix(refractColor, reflectColor, fresnel);\n  float fogAmount = getFogAmount(fragClipPosition.xyz, fogStart, fogEnd);\n  vec4 finalColor = color + vec4(lightColor, 0.0); // spec light how to add ?\n  finalColor = mix(finalColor, fogColor, fogAmount);\n  // finalColor = vec4(normale, 1.0);\n\n  float depth = texture2D(depthMap, ndc.xy).r;\n\n  gl_FragColor = finalColor;\n  \n}\n`},54735(n,o,t){t.r(o),t.d(o,{fogFactorExp2:()=>i,fogFactorLinear:()=>e,fogLocations:()=>l,fogUniforms:()=>a,getFogAmount:()=>r});const i="\nfloat fogFactorExp2(\n  const float dist,\n  const float density\n) {\n  const float LOG2 = -1.442695;\n  float d = density * dist;\n  return 1.0 - clamp(exp2(d * d * LOG2), 0.0, 1.0);\n}\n",e="\nfloat fogFactorLinear(\n  const float dist,\n  const float start,\n  const float end\n) {\n  return 1.0 - clamp((end - dist) / (end - start), 0.0, 1.0);\n}\n",r=`\n${e}\nfloat getFogAmount(vec3 position, float start, float end) {\n  float fogDistance = length(position);\n  return fogFactorLinear(fogDistance, start, end);\n}\n`,a="\nuniform vec4 fogColor;\nuniform float fogStart;\nuniform float fogEnd;\n",l=["fogStart","fogEnd","fogColor"]},84251(n,o,t){t.r(o),t.d(o,{MAX_LIGHTS:()=>i,addLightLocations:()=>r,funcLightAttenuation:()=>l,funcLightConeAttenuation:()=>a,funcLightsColor:()=>s,funcPhong:()=>c,uniformLights:()=>e});const i=10,e=`\n#define MAX_LIGHTS ${i}\nuniform int numLights;\nuniform struct Light {\n   int type;\n   vec3 position;\n   vec3 ambiant;\n   vec3 diffuse;\n   vec3 specular;\n   float radius;\n   vec3 direction;\n   float strength;\n   float brillance;\n} lights[MAX_LIGHTS];\n`,r=()=>{const n=[];for(let o=0;o<i;o+=1)n.push(`lights[${o}].type`),n.push(`lights[${o}].position`),n.push(`lights[${o}].ambiant`),n.push(`lights[${o}].diffuse`),n.push(`lights[${o}].specular`),n.push(`lights[${o}].radius`),n.push(`lights[${o}].direction`),n.push(`lights[${o}].brillance`),n.push(`lights[${o}].strength`);return n.push("numLights"),n},a="\nfloat funcLightConeAttenuation(vec3 posLum, vec3 posDirection, vec3 normale, vec3 position) {\n  float intensity = 0.0;\n  float cutoff = 0.9;\n\n  vec3 lightDirection = normalize(posLum - position); \n  vec3 spotDirection = normalize(posDirection);\n\n  // inside the cone ?\n  if (dot(spotDirection, lightDirection) > cutoff) {\n\n    vec3 n = normalize(normale);\n    intensity = max(dot(n, lightDirection), 0.0);\n\n    // if (intensity > 0.0) {\n    // vec3 eye = normalize(DataIn.eye);\n    // vec3 h = normalize(lightDirection + eye);\n    // float intSpec = max(dot(h,n), 0.0);\n    // spec = specular * pow(intSpec, shininess);\n    // }\n  }\n  return intensity;\n}\n",l="\nfloat funcLightAttenuation(vec3 posLum, float radius, vec3 normale, vec3 position) {\n  float cutoff = 0.1;\n  vec3 lightDirection = posLum - position;\n  float distance = length(lightDirection);\n  float d = max(distance - radius, 0.0);\n  lightDirection /= distance;\n  float denom = d / radius + 1.0;\n  float attenuation = 1.0 / (denom * denom);\n    \n  attenuation = (attenuation - cutoff) / (1.0 - cutoff);\n  attenuation = max(attenuation, 0.0);\n\n  float dot = max(dot(lightDirection, normale), 0.0);\n  return attenuation * dot;\n}\n",c="\nvec3 funcPhong(\n  vec3 position,\n  vec3 normale,\n  vec3 ambiant,\n  vec3 diffuse,\n  vec3 specular,\n  vec3 posLum,\n  float brillance\n  ) {\n  vec3 N = normalize(normale);\n  vec3 L = normalize(posLum - position);\n\n  // Lambert's cosine law\n  float lambertian = max(dot(N, L), 0.0);\n\n  float specularValue = 0.0;\n  if(lambertian > 0.0) {\n    vec3 R = reflect(-L, N); // Reflected light vector\n    vec3 V = normalize(-position); // Vector to viewer\n    float specAngle = max(dot(R, V), 0.0);\n    specularValue = pow(specAngle, brillance);\n  }\n\n  return vec3(ambiant * ((lambertian * diffuse) + (specularValue * specular)));\n}\n",s=`\n${c}\n${a}\n${l}\nvec3 funcLightsColor(vec3 ambiant, vec3 diffuse, vec3 specular, vec3 normale, vec3 position) {\n  vec3 finalColor = vec3(0.0);\n  for(int i = 0; i < MAX_LIGHTS; i += 1) {\n    if(i < numLights) {\n      vec3 color = funcPhong(\n        position,\n        normale,\n        ambiant * (lights[i].ambiant * lights[i].strength),\n        diffuse * (lights[i].diffuse * lights[i].strength),\n        specular * (lights[i].specular * lights[i].strength),\n        lights[i].position,\n        lights[i].brillance\n      );\n      float att = 1.0;\n      if (lights[i].type == 1) {\n        att = funcLightAttenuation(lights[i].position, lights[i].radius, normale, position);\n      } else if (lights[i].type == 2) {\n        att = funcLightConeAttenuation(lights[i].position, lights[i].direction, normale, position);\n      }\n      color *= att;\n      finalColor += color;\n    }\n  }\n  finalColor /= vec3(numLights);\n  return finalColor;\n}\n`}}]);