"use strict";(self.webpackChunkdovotori_portfolio=self.webpackChunkdovotori_portfolio||[]).push([[3681,552,4926],{43681:(n,e,t)=>{t.r(e),t.d(e,{default:()=>r});var o=t(20552),i=t(74926);const r={vertex:"\nattribute vec3 position;\nuniform mat4 projection;\nuniform mat4 model;\nuniform mat4 view;\n\nuniform float time;\nuniform float roadLength;\nuniform float roadWidth;\nuniform vec3 amplitude;\nuniform vec3 frequence;\n\nvarying vec3 fragPosition;\nvarying float fragDepth;\n\n".concat(o.PI,"\n").concat(o.funcMap,"\n").concat(i.default,"\n\nvoid main() {\n  vec3 transformed = position.xyz;\n  \n  vec3 distortion  = getDistortion(transformed.z / roadLength, frequence, amplitude, time);\n\n  transformed.x += distortion.x;\n  transformed.z += distortion.y;\n  transformed.y += -1.0 * distortion.z; \n  transformed.y -= 0.01; // place a little lower than road\n\n  float height = 0.0;\n  float gapLength = roadWidth + 4.0;\n  if (position.x > gapLength) {\n    height += funcMap(position.x, 5.0, 120.0, 1.0, 2.0);\n  } else if (position.x < -gapLength) {\n    height += funcMap(position.x, -120.0, -5.0, 1.0, 2.0);\n  }\n  if (position.x > gapLength + 2.0) {\n    height += (0.2 + cos(position.z * 0.1)) * 0.5;\n    height += (0.2 + cos(position.x * 0.1)) * 2.0;\n  } else if (position.x < -gapLength + 2.0) {\n    height += (0.2 + cos(position.z * 0.1)) * 2.0;\n    height += (0.2 + cos(position.x * 0.1)) * 0.5;\n  }\n  transformed.y += height;\n\n  fragPosition = vec3(height / 4.0);\n  fragDepth = 1.0 - smoothstep(10.0, roadLength * 8.0, transformed.z);\n  // fragDepth = 1.0 - (transformed.z * 0.2 / roadLength);\n\n  gl_Position = projection * view * model * vec4(transformed, 1.0);\n}\n"),fragment:"\nprecision mediump float;\n\nvarying vec3 fragPosition;\nvarying float fragDepth;\n\nvoid main() {\n  vec3 roadColor1 = vec3(13.0 / 255.0, 7.1 / 255.0, 32.9 / 255.0);\n  vec3 color = roadColor1 * (1.0 - fragPosition.y);\n  gl_FragColor = vec4(fragPosition, fragDepth);\n}\n",attributes:["position"],uniforms:["projection","model","view","time","roadLength","roadWidth","frequence","amplitude"]}},20552:(n,e,t)=>{t.r(e),t.d(e,{PI:()=>o,TWO_PI:()=>i,attributeColors:()=>r,varyingColors:()=>a,funcMap:()=>f,funcGrain:()=>s,funcGradiant:()=>l});var o="\n#define PI 3.14159265359\n",i="\n#define TWO_PI 6.28318530718\n",r="\nattribute vec3 ambiant;\nattribute vec3 diffuse;\nattribute vec3 specular;\nattribute float specDensity;\nattribute float opacity;\n",a="\nvarying vec3 fragAmbiant;\nvarying vec3 fragDiffuse;\nvarying vec3 fragSpecular;\nvarying float fragSpecDensity;\nvarying float fragOpacity;\n",f="\nfloat funcMap(float valeur, float minRef, float maxRef, float minDest, float maxDest) {\n  float result = minDest + (valeur - minRef) * (maxDest - minDest) / (maxRef - minRef);\n  if(result > maxDest){ result = maxDest; } else if(result < minDest){ result = minDest; }\n  return result;\n}\n",s="\nvec4 funcGrain(vec2 uv, float time, float strength) {\n  float x = (uv.x + 4.0 ) * (uv.y + 4.0 ) * (time * 10.0);\n  return vec4(mod((mod(x, 13.0) + 1.0) * (mod(x, 123.0) + 1.0), 0.01)-0.005) * strength;\n}\n",l="\n".concat(f,"\nvec4 funcGradiant(vec4 color1, vec4 color2, float start, float end, float uvAxe) {\n  float mixValue = funcMap(uvAxe, start, end, 0.0, 1.0);\n  return mix(color1, color2, mixValue);\n}\n")},74926:(n,e,t)=>{t.r(e),t.d(e,{default:()=>o});const o="\nfloat nsin(float val) {\n  return sin(val) * 0.5 + 0.5;\n}\n\nvec3 getDistortion(float progress, vec3 frequence, vec3 amplitude, float time) {\n  float movementProgressFix = 0.02;\n  float X = cos(progress * PI * frequence.x + time)\n    * amplitude.x - cos(movementProgressFix * PI * frequence.x + time) * amplitude.x;\n  float Y = nsin(progress * PI * frequence.y + time)\n    * amplitude.y - nsin(movementProgressFix * PI * frequence.y + time)* amplitude.y;\n  float Z = nsin(progress * PI * frequence.z + time)\n    * amplitude.z - nsin(movementProgressFix * PI * frequence.z + time)* amplitude.z;\n  return vec3(X, Y, Z);\n}\n"}}]);