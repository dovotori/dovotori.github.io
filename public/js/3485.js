"use strict";(self.webpackChunkdovotori=self.webpackChunkdovotori||[]).push([[3485,4227],{63485(n,o,a){a.r(o),a.d(o,{default:()=>e});var i=a(94227);const e={vertex:`\nattribute vec3 position;\nattribute vec3 normale;\n\nuniform mat4 projection;\nuniform mat4 view;\nuniform mat4 model;\nuniform mat3 normalMatrix;\n\n${i.uniformVertShadow}\n\nvarying vec3 fragPosition;\nvarying vec4 fragShadow;\nvarying vec3 fragNormale;\n\nvoid main() {\n  vec4 pos = view * model * vec4(position, 1.0);\n  fragShadow = bias * shadowProjection * shadowView * model * vec4(position, 1.0);\n  fragNormale = normalMatrix * normale;\n  fragPosition = normalize(pos.xyz);\n  gl_Position = projection * pos;\n}\n`,fragment:i.fragment,attributes:["position","normale"],uniforms:["projection","model","view","normalMatrix","resolution"].concat(i.shadowLocations)}},94227(n,o,a){a.r(o),a.d(o,{fragment:()=>s,funcShadow:()=>e,shadowLocations:()=>t,uniformFragShadow:()=>r,uniformVertShadow:()=>i});const i="\nuniform mat4 shadowView;\nuniform mat4 shadowProjection;\n\nconst mat4 bias = mat4(\n  0.5, 0.0, 0.0, 0.0,\n  0.0, 0.5, 0.0, 0.0,\n  0.0, 0.0, 0.5, 0.0,\n  0.5, 0.5, 0.5, 1.0\n);\n",e="\nfloat funcShadow(\n  vec4 pos, \n  vec2 resolution, \n  float lambertCosinus\n) {\n  if (pos.z > 1.0) {\n    return 1.0; // outside light frustum, ignore\n  }\n\n  float bias = max(shadowEpsilon * (1.0 - lambertCosinus), shadowEpsilon * 0.01);\n  vec2 texelSize = 1.0 / resolution;\n\n  // PCF (percentage closer filter)\n  float shadow = 0.0;\n  for(float y = -1.0; y <= 1.0; y += 1.0) {\n    for(float x = -1.0; x <= 1.0; x += 1.0) {\n      float depth = texture2D(shadowMap, pos.xy + vec2(x,y) * texelSize).r;\n      shadow += (depth + bias) < pos.z ? 0.0 : 1.0;\n    } \n  }\n  shadow /= 9.0;\n  return (shadow * lambertCosinus) + lighten;\n}\n",r="\nuniform sampler2D shadowMap;\nuniform float shadowEpsilon;\nuniform float lighten;\nuniform vec3 posLum;\n",t=["shadowView","shadowProjection","shadowMap","lighten","shadowEpsilon","posLum"],s=`\nprecision mediump float;\n\n${r}\n\nuniform vec2 resolution;\n\nvarying vec3 fragPosition;\nvarying vec4 fragShadow;\nvarying vec3 fragNormale;\n\n${e}\n\nvoid main() {\n  vec3 N = normalize(fragNormale);\n  vec3 L = normalize(posLum - fragPosition);\n  float lambertCosinus = max(dot(N, L), 0.0);\n  \n  float shadow = funcShadow(fragShadow, resolution, lambertCosinus);\n  gl_FragColor = vec4(vec3(shadow), 1.0);\n}\n`}}]);