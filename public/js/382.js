"use strict";(self.webpackChunkdovotori=self.webpackChunkdovotori||[]).push([[382,1014],{51014:(e,t,a)=>{a.r(t),a.d(t,{default:()=>n});const n="\nattribute vec3 position;\nattribute vec2 texture;\nvarying vec2 fragTexture;\nuniform float flipY; // 1 ou -1\n\nvoid main() {\n  fragTexture = texture;\n  gl_Position = vec4(position.x, position.y * flipY, position.z, 1.0);\n}\n"},80382:(e,t,a)=>{a.r(t),a.d(t,{default:()=>n});const n={vertex:a(51014).default,fragment:"\nprecision mediump float;\n\n#define CAP_MAX_DEPTH 0.99 // z limit to compute\n\nuniform sampler2D textureMap;\nuniform sampler2D ssaoMap;\nuniform sampler2D shadowMap;\nuniform sampler2D depthMap;\n\nvarying vec2 fragTexture;\n\nvoid main(void){\n  vec3 albedo = texture2D(textureMap, fragTexture).xyz;\n  float alpha = texture2D(textureMap, fragTexture).a;\n\n  float ssao = texture2D(ssaoMap, fragTexture).r;\n  float shadow = texture2D(shadowMap, fragTexture).r;\n\n  float depth = texture2D(depthMap, fragTexture).r * 2.0 - 1.0;\n  float opacity = depth > CAP_MAX_DEPTH ? 0.0 : alpha;\n\n  vec3 lighting = albedo * vec3(ssao) * vec3(shadow) * 2.0;\n  \n  gl_FragColor = vec4(lighting, opacity);\n}\n",attributes:["position","texture"],uniforms:["flipY","textureMap","ssaoMap","shadowMap","depthMap"]}}}]);