"use strict";(self.webpackChunkdovotori=self.webpackChunkdovotori||[]).push([[4472,7719,9044,6507],{57719:(n,e,o)=>{o.r(e),o.d(e,{default:()=>r});const r="\nattribute vec3 position;\nattribute vec2 texture;\nvarying vec2 fragTexture;\nuniform float flipY; // 1 ou -1\n\nvoid main() {\n  fragTexture = texture;\n  gl_Position = vec4(position.x, position.y * flipY, position.z, 1.0);\n}\n"},29044:(n,e,o)=>{o.r(e),o.d(e,{default:()=>r});const r="\n#define MIN_HEIGHT 2.0\n#define MAX_HEIGHT 4.5\n\nvec3 sundir = normalize(vec3(1.0, 0.75, 1.0));\n\nfloat planeIntersect(vec3 ro, vec3 rd, float plane) {\n  float h = plane - ro.y;\n  return h / rd.y;\n}\n\nfloat noiseSpe(sampler2D tex, vec3 x, float time, vec2 wind) {\n  vec3 f = fract(x);\n  vec3 p = floor(x);\n  f = f * f * (3.0 - 2.0 * f);\n  \n  p.xz += wind * time;\n  vec2 uv = (p.xz + vec2(37.0, 17.0) * p.y) + f.xz;\n  vec2 rg = texture2D(tex, (uv + 0.5) / 256.0, 0.0).yx;\n  return mix(rg.x, rg.y, f.y);\n}\n\nfloat fractalNoise(sampler2D tex, vec3 p, float time, vec2 wind) {\n  float f = 0.0;\n  // add animation\n  // p = p - vec3(1.0, 1.0, 0.0) * time * 0.1;\n  p = p * 3.0;\n  f += 0.50000 * noiseSpe(tex, p, time, wind); p = 2.0 * p;\n\tf += 0.25000 * noiseSpe(tex, p, time, wind); p = 2.0 * p;\n\tf += 0.12500 * noiseSpe(tex, p, time, wind); p = 2.0 * p;\n\tf += 0.06250 * noiseSpe(tex, p, time, wind); p = 2.0 * p;\n  f += 0.03125 * noiseSpe(tex, p, time, wind);\n  return f;\n}\n\nfloat density(sampler2D tex, vec3 pos, float time, vec2 wind) {    \n  float den = 3.0 * fractalNoise(tex, pos * 0.3, time, wind) - 2.0 + (pos.y - MIN_HEIGHT);\n  float edge = 1.0 - smoothstep(MIN_HEIGHT, MAX_HEIGHT, pos.y);\n  edge *= edge;\n  den *= edge;\n  den = clamp(den, 0.0, 1.0);\n  return den;\n}\n\nvec3 raymarching(\n  sampler2D tex,\n  vec3 ro,\n  vec3 rd,\n  float t,\n  vec3 backColor,\n  float time,\n  vec2 wind\n) {   \n  vec4 sum = vec4(0.0);\n  vec3 pos = ro + rd * t;\n\n  vec3 fix1 = vec3(0.65, 0.7, 0.75);\n  vec3 fix2 = vec3(1.0, 0.6, 0.3);\n\n  for (int i = 0; i < 40; i++) {\n    if (sum.a > 0.99 || \n      pos.y < (MIN_HEIGHT-1.0) || \n      pos.y > (MAX_HEIGHT+1.0)) break;\n    \n    float den = density(tex, pos, time, wind);\n\n    if (den > 0.01) {\n      float dif = clamp((den - density(tex, pos + 0.3 * sundir, time, wind)) / 0.6, 0.0, 1.0);\n      vec3 lin = fix1 * 1.5 + fix2 * dif;        \n      vec4 color = vec4(mix(SKY_COLOR * 1.1, CLOUD_COLOR, den), den);\n      color.rgb *= lin;\n\n      // front to back blending    \n      color.a *= 0.5;\n      color.rgb *= color.a;\n      sum = sum + color * (1.0 - sum.a); \n    }\n    \n    t += max(0.05, 0.02 * t);\n    pos = ro + rd * t;\n  }\n  \n  sum = clamp(sum, 0.0, 1.0);\n  float h = rd.y;\n  sum.rgb = mix(sum.rgb, backColor, exp(-20.0 * h * h));\n  \n  return mix(backColor, sum.xyz, sum.a);\n}\n\nvec3 getClouds(sampler2D tex, vec2 uv, float time, vec3 backColor, vec2 wind) {\n  vec3 color = backColor;\n  vec3 ro = vec3(0.0, 0.0, -2.0); // size\n  vec3 rd = normalize(vec3(uv, 1.5));\n  float dist = planeIntersect(ro, rd, MIN_HEIGHT);\n  if (dist > 0.0) {\n    color = raymarching(tex, ro, rd, dist, color, time, wind);\n  }\n  return color;\n}\n"},36507:(n,e,o)=>{o.r(e),o.d(e,{default:()=>r});const r="\nvec3 getSunSky(vec2 uv) {\n  float horizonY = uv.y - 0.05;\n\tvec3 rayDir = normalize(vec3(uv.x, horizonY, 1.5));\n  vec3 sundir = normalize(vec3(0.0, 0.1, 1.0));\n  float yd = min(rayDir.y, 0.0);\n  rayDir.y = max(rayDir.y, 0.0);\n  vec3 color = vec3(0.0);\n  color += SUN_SKY_COLOR_1 * vec3(1.0, 0.4 - exp(-rayDir.y * 20.0) * 0.3, 0.2)\n    * exp(-rayDir.y * 9.0);\n  color += SUN_SKY_COLOR_2 * (1.0 - exp(-rayDir.y * 8.0)) * exp(-rayDir.y * 0.9) ; \n  // color = mix(color * 1.2, vec3(0.3),  1.0 - exp(yd * 100.0)); // Fog\n  color += SUN_COLOR * pow(max(dot(rayDir, sundir), 0.0), 15.0) * SUN_INTENSITY; // Sun big halo\n  color += pow(max(dot(rayDir, sundir), 0.0), 150.0) * 0.15; // Sun little halo\n  return color;\n}\n"},14472:(n,e,o)=>{o.r(e),o.d(e,{default:()=>a});var r=o(29044),t=o(36507),i=o(57719);const c=`\nprecision mediump float;\n\nuniform vec2 resolution;\nuniform vec2 wind;\nuniform float time;\nuniform sampler2D textureMap;\n\n#define SKY_COLOR vec3(59.0 / 255.0, 176.0 / 255.0, 178.0 / 255.0)\n#define CLOUD_COLOR vec3(255.0 / 255.0, 255.0 / 255.0, 250.0 / 255.0)\n${r.default}\n\n#define SUN_SKY_COLOR_1 vec3(13.0 / 255.0, 7.1 / 255.0, 32.9 / 255.0)\n#define SUN_SKY_COLOR_2 vec3(193.0 / 255.0, 2.0 / 255.0, 117.0 / 255.0)\n#define SUN_SKY_COLOR_3 vec3(97.0 / 255.0, 191.0 / 255.0, 193.0 / 255.0)\n#define SUN_COLOR vec3(255.0 / 255.0, 113.0 / 255.0, 45.0 / 255.0)\n#define SUN_INTENSITY 0.6\n${t.default}\n\nvarying vec2 fragTexture;\n\n\nvec3 getColor(vec2 p, vec3 rd) {\n  float sun = clamp(dot(sundir, rd), 0.0, 1.0);\n  vec3 color = mix(vec3(0.78, 0.78, 0.7), vec3(0.3, 0.4, 0.5), p.y * 0.5 + 0.5);\n  color += 0.5 * vec3(1.0, 0.5, 0.1) * pow(sun, 8.0);\n  return color;\n}\n\nvoid main() {\n  vec2 uv = -1.0 + 2.0 * fragTexture;\n  // vec3 color = getColor(uv, normalize(vec3(uv, 1.5)));\n\n  vec3 color = getSunSky(uv);\n\n  color = getClouds(textureMap, uv, time, color, wind);\n  gl_FragColor = vec4(color, 1.0);\n}\n`,a={vertex:i.default,fragment:c,attributes:["position","texture"],uniforms:["flipY","textureMap","resolution","time","wind"]}}}]);