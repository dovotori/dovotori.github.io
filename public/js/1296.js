"use strict";(self.webpackChunkdovotori=self.webpackChunkdovotori||[]).push([[1014,1296,4251],{51014:(n,t,i)=>{i.r(t),i.d(t,{default:()=>e});const e="\nattribute vec3 position;\nattribute vec2 texture;\nvarying vec2 fragTexture;\nuniform float flipY; // 1 ou -1\n\nvoid main() {\n  fragTexture = texture;\n  gl_Position = vec4(position.x, position.y * flipY, position.z, 1.0);\n}\n"},1296:(n,t,i)=>{i.r(t),i.d(t,{default:()=>l});var e=i(84251),o=i(51014);const a=`\nprecision mediump float;\n\n#define CAP_MAX_DEPTH 0.99 // z limit to compute\n\nuniform sampler2D depthMap;\nuniform sampler2D normalMap;\nuniform sampler2D positionMap;\nvarying vec2 fragTexture;\n\n${e.uniformLights}\n\n${e.funcLightAttenuation}\n${e.funcLightConeAttenuation}\n\nvec4 funcDiffuseColor() {\n  vec3 finalColor = vec3(0.0);\n  float fragDepth = texture2D(depthMap, fragTexture).r * 2.0 - 1.0;\n  if (fragDepth > CAP_MAX_DEPTH) { return vec4(0.0); } // if too far\n\n  vec3 N = texture2D(normalMap, fragTexture).xyz;\n  vec3 P = texture2D(positionMap, fragTexture).xyz;\n  \n  for(int i = 0; i < MAX_LIGHTS; i += 1) {\n    if(i < numLights) {\n      vec3 lightPos = lights[i].position;\n      vec3 L = normalize(lightPos - P);\n      float lambertCosinus = max(dot(N, L), 0.0);\n      vec3 color = lights[i].diffuse * lambertCosinus;\n      float att = 1.0;\n      // if (lights[i].type == 1) {\n      //   att = funcLightAttenuation(lights[i].position, lights[i].radius, N, P);\n      // } else if (lights[i].type == 2) {\n      //   att = funcLightConeAttenuation(lights[i].position, lights[i].direction, N, P);\n      // }\n      color *= lights[i].strength;\n      color *= att;\n      finalColor += color;\n    }\n  }\n  return vec4(finalColor, 1.0);\n}\n\nvoid main() {\n  gl_FragColor = funcDiffuseColor();\n}\n`,l={vertex:o.default,fragment:a,attributes:["position","texture"],uniforms:["flipY","depthMap","normalMap","positionMap"].concat((0,e.addLightLocations)())}},84251:(n,t,i)=>{i.r(t),i.d(t,{MAX_LIGHTS:()=>e,addLightLocations:()=>a,funcLightAttenuation:()=>s,funcLightConeAttenuation:()=>l,funcLightsColor:()=>c,funcPhong:()=>r,uniformLights:()=>o});const e=10,o=`\n#define MAX_LIGHTS ${e}\nuniform int numLights;\nuniform struct Light {\n   int type;\n   vec3 position;\n   vec3 ambiant;\n   vec3 diffuse;\n   vec3 specular;\n   float radius;\n   vec3 direction;\n   float strength;\n   float brillance;\n} lights[MAX_LIGHTS];\n`,a=()=>{const n=[];for(let t=0;t<e;t+=1)n.push(`lights[${t}].type`),n.push(`lights[${t}].position`),n.push(`lights[${t}].ambiant`),n.push(`lights[${t}].diffuse`),n.push(`lights[${t}].specular`),n.push(`lights[${t}].radius`),n.push(`lights[${t}].direction`),n.push(`lights[${t}].brillance`),n.push(`lights[${t}].strength`);return n.push("numLights"),n},l="\nfloat funcLightConeAttenuation(vec3 posLum, vec3 posDirection, vec3 normale, vec3 position) {\n  float intensity = 0.0;\n  float cutoff = 0.9;\n\n  vec3 lightDirection = normalize(posLum - position); \n  vec3 spotDirection = normalize(posDirection);\n\n  // inside the cone ?\n  if (dot(spotDirection, lightDirection) > cutoff) {\n\n    vec3 n = normalize(normale);\n    intensity = max(dot(n, lightDirection), 0.0);\n\n    // if (intensity > 0.0) {\n    // vec3 eye = normalize(DataIn.eye);\n    // vec3 h = normalize(lightDirection + eye);\n    // float intSpec = max(dot(h,n), 0.0);\n    // spec = specular * pow(intSpec, shininess);\n    // }\n  }\n  return intensity;\n}\n",s="\nfloat funcLightAttenuation(vec3 posLum, float radius, vec3 normale, vec3 position) {\n  float cutoff = 0.1;\n  vec3 lightDirection = posLum - position;\n  float distance = length(lightDirection);\n  float d = max(distance - radius, 0.0);\n  lightDirection /= distance;\n  float denom = d / radius + 1.0;\n  float attenuation = 1.0 / (denom * denom);\n    \n  attenuation = (attenuation - cutoff) / (1.0 - cutoff);\n  attenuation = max(attenuation, 0.0);\n\n  float dot = max(dot(lightDirection, normale), 0.0);\n  return attenuation * dot;\n}\n",r="\nvec3 funcPhong(\n  vec3 position,\n  vec3 normale,\n  vec3 ambiant,\n  vec3 diffuse,\n  vec3 specular,\n  vec3 posLum,\n  float brillance\n  ) {\n  vec3 N = normalize(normale);\n  vec3 L = normalize(posLum - position);\n\n  // Lambert's cosine law\n  float lambertian = max(dot(N, L), 0.0);\n\n  float specularValue = 0.0;\n  if(lambertian > 0.0) {\n    vec3 R = reflect(-L, N); // Reflected light vector\n    vec3 V = normalize(-position); // Vector to viewer\n    float specAngle = max(dot(R, V), 0.0);\n    specularValue = pow(specAngle, brillance);\n  }\n\n  return vec3(ambiant * ((lambertian * diffuse) + (specularValue * specular)));\n}\n",c=`\n${r}\n${l}\n${s}\nvec3 funcLightsColor(vec3 ambiant, vec3 diffuse, vec3 specular, vec3 normale, vec3 position) {\n  vec3 finalColor = vec3(0.0);\n  for(int i = 0; i < MAX_LIGHTS; i += 1) {\n    if(i < numLights) {\n      vec3 color = funcPhong(\n        position,\n        normale,\n        ambiant * (lights[i].ambiant * lights[i].strength),\n        diffuse * (lights[i].diffuse * lights[i].strength),\n        specular * (lights[i].specular * lights[i].strength),\n        lights[i].position,\n        lights[i].brillance\n      );\n      float att = 1.0;\n      if (lights[i].type == 1) {\n        att = funcLightAttenuation(lights[i].position, lights[i].radius, normale, position);\n      } else if (lights[i].type == 2) {\n        att = funcLightConeAttenuation(lights[i].position, lights[i].direction, normale, position);\n      }\n      color *= att;\n      finalColor += color;\n    }\n  }\n  finalColor /= vec3(numLights);\n  return finalColor;\n}\n`}}]);