"use strict";(self.webpackChunkdovotori=self.webpackChunkdovotori||[]).push([[2112,5059],{62112:(e,t,n)=>{n.r(t),n.d(t,{default:()=>r});const r={vertex:`\nattribute vec3 position;\nattribute vec2 texture;\nuniform mat4 projection;\nuniform mat4 model;\nuniform mat4 view;\nuniform int inverseX;\nuniform float spriteRefSize;\nuniform vec2 spriteUV;\nuniform vec2 spriteGrid;\nuniform vec2 spriteSize;\nuniform vec2 spritePivot;\nvarying vec2 fragTexture;\n\n${n(75059).funcMap}\n\nvoid main() {\n  vec2 relPos = spriteUV / spriteGrid;\n  vec2 relSize = spriteSize / spriteGrid;\n  float texX = funcMap(\n    texture.x,\n    0.0 + float(inverseX),\n    1.0 - float(inverseX),\n    relPos.x,\n    relPos.x + relSize.x\n  );\n\tfloat texY = funcMap(texture.y, 1.0, 0.0, relPos.y,  relPos.y + relSize.y);\n  fragTexture = vec2(texX, texY);\n  \n  // float relW = (spriteSize.x / spriteRefSize);\n  // float relH = (spriteSize.y / spriteRefSize);  \n  \n  // float finalX = funcMap(position.x, -1.0, 1.0, -relW, relW);\n  // float finalY = funcMap(position.y, -1.0, 1.0, -relH, relH);\n  \n  // // place en bas\n  // if (spritePivot.y == -1.0) {\n  //   float offsetY = relH - 1.0;\n  //   finalY += offsetY;\n  // }\n\n  // // place pivot\n  // float offsetX = relW * -0.5;\n  // if (spritePivot.x != -1.0) {\n  //   offsetX = (spritePivot.x / spriteGrid.x);\n  // }\n  // finalX += offsetX;\n\n  gl_Position = projection * view * model * vec4(position, 1.0);\n}\n`,fragment:"\nprecision mediump float;\nvarying vec2 fragTexture;\nuniform vec3 tint;\nuniform int inverseColor;\nuniform float damage;\nuniform sampler2D textureMap;\nvoid main() {\n  \n  // rgb\n  // vec2 delta = vec2(0.01,0.01);\n  // vec2 center = vec2(0.5,0.5);\n  // vec2 dir = fragTexture - center;\n  // vec2 value = dir * delta;\n\t// vec4 c1 = texture2D(textureMap, fragTexture - value);\n\t// vec4 c2 = texture2D(textureMap, fragTexture);\n\t// vec4 c3 = texture2D(textureMap, fragTexture + value);\n  // vec4 color = vec4(c1.r, c2.g, c3.b, c1.a + c2.a + c3.b);\n\n\tvec4 color = texture2D(textureMap, fragTexture);\n\tcolor.x *= tint.x; \n\tcolor.y *= tint.y; \n\tcolor.z *= tint.z; \n  if (inverseColor == 1) {\n    color.x = 1.0 - color.x; \n\t  color.y = 1.0 - color.y; \n\t  color.z = 1.0 - color.z; \n  }\n  color.xyz += vec3(damage) * vec3(1.0,0.0,0.0);\n  gl_FragColor = color;\n}\n",attributes:["position","texture"],uniforms:["projection","model","view","textureMap","spriteUV","spriteGrid","spriteSize","spriteRefSize","spritePivot","inverseX","tint","inverseColor","damage"]}},75059:(e,t,n)=>{n.r(t),n.d(t,{PI:()=>r,TWO_PI:()=>i,attributeColors:()=>o,funcGradiant:()=>c,funcGrain:()=>l,funcMap:()=>f,varyingColors:()=>a});const r="\n#define PI 3.14159265359\n",i="\n#define TWO_PI 6.28318530718\n",o="\nattribute vec3 ambiant;\nattribute vec3 diffuse;\nattribute vec3 specular;\nattribute float specDensity;\nattribute float opacity;\n",a="\nvarying vec3 fragAmbiant;\nvarying vec3 fragDiffuse;\nvarying vec3 fragSpecular;\nvarying float fragSpecDensity;\nvarying float fragOpacity;\n",f="\nfloat funcMap(float valeur, float minRef, float maxRef, float minDest, float maxDest) {\n  float result = minDest + (valeur - minRef) * (maxDest - minDest) / (maxRef - minRef);\n  if(result > maxDest){ result = maxDest; } else if(result < minDest){ result = minDest; }\n  return result;\n}\n",l="\nvec4 funcGrain(vec2 uv, float time, float strength) {\n  float x = (uv.x + 4.0 ) * (uv.y + 4.0 ) * (time * 10.0);\n  return vec4(mod((mod(x, 13.0) + 1.0) * (mod(x, 123.0) + 1.0), 0.01)-0.005) * strength;\n}\n",c=`\n${f}\nvec4 funcGradiant(vec4 color1, vec4 color2, float start, float end, float uvAxe) {\n  float mixValue = funcMap(uvAxe, start, end, 0.0, 1.0);\n  return mix(color1, color2, mixValue);\n}\n`}}]);