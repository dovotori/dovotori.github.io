"use strict";(self.webpackChunkdovotori_portfolio=self.webpackChunkdovotori_portfolio||[]).push([[2581,552,6215,2362,4956,2235],{92581:(n,e,t)=>{t.r(e),t.d(e,{default:()=>r});var o=t(44956),a=t(42235);const r={vertex:"\nattribute vec3 position;\nuniform mat4 projection;\nuniform mat4 model;\nuniform mat4 view;\nuniform mat3 normalMatrix;\n\nuniform float fogStart;\nuniform float fogEnd;\n\n".concat(o.uniformVertShadow,"\n\n").concat(a.getNaturalHeight,"\n").concat(a.getNormale,"\n\nvarying vec3 fragPosition;\nvarying vec4 fragShadow;\nvarying vec3 fragNormale;\n\nvoid main() {\n  vec3 tranformed = position;\n\n  if (position.y == 0.0) {\n    vec2 coord = position.xz + moving;\n    tranformed.y = getNaturalHeight(coord);\n  }\n\n  vec4 pos = view * model * vec4(tranformed, 1.0);\n  fragShadow = bias * shadowProjection * shadowView * model * vec4(tranformed, 1.0);\n  fragNormale = normalMatrix * getNormale(position, tranformed);\n  fragPosition = normalize(pos.xyz);\n  gl_Position = projection * pos;\n}\n"),fragment:o.fragment,attributes:["position"],uniforms:["projection","model","view","normalMatrix","resolution"].concat(a.locations).concat(o.shadowLocations)}},20552:(n,e,t)=>{t.r(e),t.d(e,{PI:()=>o,TWO_PI:()=>a,attributeColors:()=>r,funcGradiant:()=>f,funcGrain:()=>s,funcMap:()=>c,varyingColors:()=>i});var o="\n#define PI 3.14159265359\n",a="\n#define TWO_PI 6.28318530718\n",r="\nattribute vec3 ambiant;\nattribute vec3 diffuse;\nattribute vec3 specular;\nattribute float specDensity;\nattribute float opacity;\n",i="\nvarying vec3 fragAmbiant;\nvarying vec3 fragDiffuse;\nvarying vec3 fragSpecular;\nvarying float fragSpecDensity;\nvarying float fragOpacity;\n",c="\nfloat funcMap(float valeur, float minRef, float maxRef, float minDest, float maxDest) {\n  float result = minDest + (valeur - minRef) * (maxDest - minDest) / (maxRef - minRef);\n  if(result > maxDest){ result = maxDest; } else if(result < minDest){ result = minDest; }\n  return result;\n}\n",s="\nvec4 funcGrain(vec2 uv, float time, float strength) {\n  float x = (uv.x + 4.0 ) * (uv.y + 4.0 ) * (time * 10.0);\n  return vec4(mod((mod(x, 13.0) + 1.0) * (mod(x, 123.0) + 1.0), 0.01)-0.005) * strength;\n}\n",f="\n".concat(c,"\nvec4 funcGradiant(vec4 color1, vec4 color2, float start, float end, float uvAxe) {\n  float mixValue = funcMap(uvAxe, start, end, 0.0, 1.0);\n  return mix(color1, color2, mixValue);\n}\n")},96215:(n,e,t)=>{t.r(e),t.d(e,{anothorNoise1D:()=>s,anothorNoise2D:()=>f,funcNoise:()=>r,funcPnoise:()=>i,funcSnoise:()=>c});var o=t(32362),a=t(20552),r="\n".concat(o.funcRand,"\nfloat noise(vec2 n) {\n\tconst vec2 d = vec2(0.0, 1.0);\n  vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\treturn mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n"),i="\n".concat(a.PI,"\n").concat(o.funcRand,"\nfloat noise(vec2 p, float freq) {\n\tfloat unit = freq;\n\tvec2 ij = floor(p / unit);\n\tvec2 xy = mod(p, unit) / unit;\n\t//xy = 3. * xy * xy -2. * xy * xy * xy;\n\txy = .5 * (1. - cos(PI * xy));\n\tfloat a = rand((ij + vec2(0.,0.)));\n\tfloat b = rand((ij + vec2(1.,0.)));\n\tfloat c = rand((ij + vec2(0.,1.)));\n\tfloat d = rand((ij + vec2(1.,1.)));\n\tfloat x1 = mix(a, b, xy.x);\n\tfloat x2 = mix(c, d, xy.x);\n\treturn mix(x1, x2, xy.y);\n}\n\nfloat pnoise(vec2 p){\n\tfloat persistance = .5;\n\tfloat n = 0.;\n\tfloat normK = 0.;\n\tfloat f = 4.;\n\tfloat amp = 1.;\n\tint iCount = 0;\n\tfor (int i = 0; i<50; i++){\n\t\tn+=amp*noise(p, f);\n\t\tf*=2.;\n\t\tnormK+=amp;\n\t\tamp*=persistance;\n\t\tiCount++;\n\t}\n\tfloat nf = n/normK;\n\treturn nf*nf*nf*nf;\n}\n"),c="\n//\tSimplex 3D Noise \n//\tby Ian McEwan, Ashima Arts\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nfloat snoise(vec3 v){ \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //  x0 = x0 - 0. + 0.0 * C \n  vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n  vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n  vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n// Permutations\n  i = mod(i, 289.0 ); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients\n// ( N*N points uniformly over a square, mapped onto an octahedron.)\n  float n_ = 1.0/7.0; // N=7\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}\n",s="\nfloat hash(float p) {\n  p = fract(p * 0.011);\n  p *= p + 7.5;\n  p *= p + p;\n  return fract(p);\n}\n\nfloat noise(float x) {\n  float i = floor(x);\n  float f = fract(x);\n  float u = f * f * (3.0 - 2.0 * f);\n  return mix(hash(i), hash(i + 1.0), u);\n}\n",f="\nfloat hash(vec2 p) {\n  vec3 p3 = fract(vec3(p.xyx) * 0.13);\n  p3 += dot(p3, p3.yzx + 3.333);\n  return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat noise(vec2 x) {\n  vec2 i = floor(x);\n  vec2 f = fract(x);\n\n\t// Four corners in 2D of a tile\n\tfloat a = hash(i);\n  float b = hash(i + vec2(1.0, 0.0));\n  float c = hash(i + vec2(0.0, 1.0));\n  float d = hash(i + vec2(1.0, 1.0));\n\n  // Simple 2D lerp using smoothstep envelope between the values.\n\t// return vec3(mix(mix(a, b, smoothstep(0.0, 1.0, f.x)),\n\t//\t\t\tmix(c, d, smoothstep(0.0, 1.0, f.x)),\n\t//\t\t\tsmoothstep(0.0, 1.0, f.y)));\n\n\t// Same code, with the clamps in smoothstep and common subexpressions\n\t// optimized away.\n  vec2 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n"},32362:(n,e,t)=>{t.r(e),t.d(e,{funcRand:()=>o,funcRandFloat:()=>r,funcRandRange:()=>a,randRGBA:()=>i});var o="\n// between 0 - 1\nfloat rand(vec2 n) {\n  return fract(sin(dot(n.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n",a="\n".concat(o,"\nfloat randomRange(vec2 seed, float min, float max) {\n\treturn min + rand(seed) * (max - min);\n}\n"),r="\nfloat randFloat(float n){ return fract(sin(n) * 43758.5453123); }\n",i="\n#define PHI 1.61803398874989484820459\n\nfloat goldNoise(vec2 xy, float seed) {\n  return fract(tan(distance(xy * PHI, xy) * seed) * xy.x);\n}\n\nvec4 randRGBA (vec2 nn, float time) {\n  vec2 n = nn; \n  return vec4(\n    goldNoise(n, fract(time) + 1.0), // r\n    goldNoise(n, fract(time) + 2.0), // g\n    goldNoise(n, fract(time) + 3.0), // b\n    1.0);\n}\n"},44956:(n,e,t)=>{t.r(e),t.d(e,{fragment:()=>c,funcShadow:()=>a,shadowLocations:()=>i,uniformFragShadow:()=>r,uniformVertShadow:()=>o});var o="\nuniform mat4 shadowView;\nuniform mat4 shadowProjection;\n\nconst mat4 bias = mat4(\n  0.5, 0.0, 0.0, 0.0,\n  0.0, 0.5, 0.0, 0.0,\n  0.0, 0.0, 0.5, 0.0,\n  0.5, 0.5, 0.5, 1.0\n);\n",a="\nfloat funcShadow(\n  vec4 pos, \n  vec2 resolution, \n  float lambertCosinus\n) {\n  if (pos.z > 1.0) {\n    return 1.0; // outside light frustum, ignore\n  }\n\n  float bias = max(shadowEpsilon * (1.0 - lambertCosinus), shadowEpsilon * 0.01);\n  vec2 texelSize = 1.0 / resolution;\n\n  // PCF (percentage closer filter)\n  float shadow = 0.0;\n  for(float y = -1.0; y <= 1.0; y += 1.0) {\n    for(float x = -1.0; x <= 1.0; x += 1.0) {\n      float depth = texture2D(shadowMap, pos.xy + vec2(x,y) * texelSize).r;\n      shadow += (depth + bias) < pos.z ? 0.0 : 1.0;\n    } \n  }\n  shadow /= 9.0;\n  return (shadow * lambertCosinus) + lighten;\n}\n",r="\nuniform sampler2D shadowMap;\nuniform float shadowEpsilon;\nuniform float lighten;\nuniform vec3 posLum;\n",i=["shadowView","shadowProjection","shadowMap","lighten","shadowEpsilon","posLum"],c="\nprecision mediump float;\n\n".concat(r,"\n\nuniform vec2 resolution;\n\nvarying vec3 fragPosition;\nvarying vec4 fragShadow;\nvarying vec3 fragNormale;\n\n").concat(a,"\n\nvoid main() {\n  vec3 N = normalize(fragNormale);\n  vec3 L = normalize(posLum - fragPosition);\n  float lambertCosinus = max(dot(N, L), 0.0);\n  \n  float shadow = funcShadow(fragShadow, resolution, lambertCosinus);\n  gl_FragColor = vec4(vec3(shadow), 1.0);\n}\n")},42235:(n,e,t)=>{t.r(e),t.d(e,{funcWave:()=>c,getNaturalHeight:()=>r,getNormale:()=>s,locations:()=>i});var o=t(96215),a=t(20552),r="\n".concat(o.anothorNoise2D,"\n\n#define NB_OCTAVES 10\nuniform float lacunarity; // frequency of noise octave\nuniform float persistance; // influence of noise octave\n\nuniform vec2 moving;\nuniform vec2 gridSize;\n\nfloat getNaturalHeight(vec2 coor) {\n  float result = 0.0;\n  float allAmpli = 0.0;\n  for(int i = 0; i < NB_OCTAVES; i += 1) {\n    float frequency = pow(lacunarity, float(i));\n    float amplitude = pow(persistance, float(i));\n    result += noise(coor * frequency) * amplitude;\n    allAmpli += amplitude;\n  }\n  return result / allAmpli;\n}"),i=["octaves","lacunarity","persistance","moving","gridSize"],c="\n".concat(a.PI,"\n\nstruct Wave {\n  vec3 position;\n\tvec3 tangent;\n\tvec3 binormal;\n};\n\nWave funcWave(\n  vec2 uv,\n  float steepness, // raideur -> steepness prevent looping (replace amplitude) entre 0 et 1\n  float wavelength,\n  vec2 direction,\n  vec2 time,\n  vec3 tangent,\n  vec3 binormal\n) {\n  vec2 D = normalize(direction);\n\tfloat K = 2.0 * PI / wavelength;\n\tfloat C = sqrt(9.8 / K);\n  float F = K * (dot(D, uv) - C * time.y);\n\n\tfloat A = steepness / K;\n\n\tvec3 p = vec3(uv.x, 0.0, uv.y);\n\tp.x += D.x * (A * cos(F));\n\tp.y = A * sin(F);\n\tp.z += D.y * (A * cos(F));\n\n  // on en profite pour update tangent et binormal\n  tangent += vec3(\n    -1.0 - D.x * D.x * (steepness * sin(F)),\n    D.x * (steepness * cos(F)),\n    -D.x * D.y * (steepness * sin(F))\n  );\n\n  binormal += vec3(\n    -D.x * D.y * (steepness * sin(F)),\n    D.y * (steepness * cos(F)),\n    - D.y * D.y * (steepness * sin(F))\n  );\n\n\treturn Wave(\n    p,\n    tangent,\n    binormal\n  );\n}\n"),s="\nvec3 computeNormale(vec3 p0, vec3 p1, vec3 p2) {\n  return cross(p1 - p0, p2 - p0);\n}\n\nvec3 roundNormale(vec3 position, vec2 moving) {\n  vec2 betweenPoints = 2.0 / gridSize;\n\n  vec2 coordP0 = position.xz + vec2(betweenPoints.x, 0.0) + moving;\n  vec2 coordP1 = position.xz + vec2(betweenPoints.x, 0.0) + moving;\n  vec2 coordP2 = position.xz + vec2(0.0, betweenPoints.y) + moving;\n  \n  vec3 p0 = vec3(0.0, position.y, 0.0);\n  vec3 p1 = vec3(betweenPoints.x, getNaturalHeight(coordP1), 0.0);\n  vec3 p2 = vec3(0.0, getNaturalHeight(coordP2), betweenPoints.y);\n\n  return normalize(computeNormale(p0, p2, p1));\n}\n\nvec3 getNormale(vec3 position, vec3 tranformed) {\n  vec3 normale = vec3(0.0);\n  if (position.y == 0.0) {\n    normale = roundNormale(tranformed, moving);\n  }\n  if (position.x == 1.0) {\n    normale = vec3(1.0 ,0.0, 0.0);\n  } else if (position.x == -1.0) {\n    normale = vec3(-1.0 ,0.0, 0.0);\n  } else if (position.z == 1.0) {\n    normale = vec3(0.0 ,0.0, 1.0);\n  } else if (position.z == -1.0) {\n    normale = vec3(0.0 ,0.0, -1.0);\n  }\n  return normale;\n}\n"}}]);