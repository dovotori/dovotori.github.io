"use strict";(self.webpackChunkdovotori_portfolio=self.webpackChunkdovotori_portfolio||[]).push([[2587,7719],{57719:(t,e,n)=>{n.r(e),n.d(e,{default:()=>l});const l="\nattribute vec3 position;\nattribute vec2 texture;\nvarying vec2 fragTexture;\nuniform float flipY; // 1 ou -1\n\nvoid main() {\n  fragTexture = texture;\n  gl_Position = vec4(position.x, position.y * flipY, position.z, 1.0);\n}\n"},52587:(t,e,n)=>{n.r(e),n.d(e,{default:()=>l});const l={vertex:n(57719).default,fragment:"\nprecision mediump float;\n\nuniform sampler2D textureMap;\nuniform vec2 resolution;\nvarying vec2 fragTexture;\n\n#define FXAA_REDUCE_MIN 1.0 / 128.0 // empeche division par zero\n#define FXAA_REDUCE_MUL 1.0 / 8.0 // controle en fonction de la lumina\n#define FXAA_SPAN_MAX 6.0 // limite l'expansion du blur\n\nvec4 applyFXAA(sampler2D tex, vec2 st, vec2 resolution) {\n\tvec2 inverseViewportSize = vec2(1.0 / resolution.x, 1.0 / resolution.y);\n\n\tvec3 luma = vec3(0.299, 0.587, 0.114); // // reference pour avoir la luminosite d'un pixel\n\t// on regarde la luminosite sur les pixels en croix autour du pixel\n\tfloat lumaTL = dot(luma, texture2D(tex, st + (vec2(-1.0, -1.0) * inverseViewportSize)).xyz);\n\tfloat lumaTR = dot(luma, texture2D(tex, st + (vec2(1.0, -1.0) * inverseViewportSize)).xyz);\n\tfloat lumaBL = dot(luma, texture2D(tex, st + (vec2(-1.0, 1.0) * inverseViewportSize)).xyz);\n\tfloat lumaBR = dot(luma, texture2D(tex, st + (vec2(1.0, 1.0) * inverseViewportSize)).xyz);\n\tfloat lumaM = dot(luma, texture2D(tex, st).xyz);\n\n\t// EDGE DETECTION\n\tvec2 dir;\n\tdir.x = -((lumaTL + lumaTR) - (lumaBL + lumaBR));\n\tdir.y = ((lumaTL + lumaBL) - (lumaTR + lumaBR));\n\tfloat dirReduce = max(\n\t\t(lumaTL + lumaTR + lumaBL + lumaBR) * (FXAA_REDUCE_MUL * 0.25), FXAA_REDUCE_MIN\n\t);\n\tfloat inverseDirAdjustment = 1.0/(min(abs(dir.x), abs(dir.y)) + dirReduce);\n\tdir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),\n\t\tmax(\n\t\t\tvec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX), dir * inverseDirAdjustment)\n\t\t) * inverseViewportSize;\n\n\t// BLUR\n\tvec4 result1 = (1.0 / 2.0) * (\n\t\ttexture2D(tex, st + (dir * vec2(1.0 / 3.0 - 0.5))) +\n\t\ttexture2D(tex, st + (dir * vec2(2.0 / 3.0 - 0.5))));\n\tvec4 result2 = result1 * (1.0 / 2.0) + (1.0 / 4.0) * (\n\t\ttexture2D(tex, st + (dir * vec2(0.0 / 3.0 - 0.5))) +\n\t\ttexture2D(tex, st + (dir * vec2(3.0 / 3.0 - 0.5))));\n\n\tfloat lumaMin = min(lumaM, min(min(lumaTL, lumaTR), min(lumaBL, lumaBR)));\n\tfloat lumaMax = max(lumaM, max(max(lumaTL, lumaTR), max(lumaBL, lumaBR)));\n\tfloat lumaResult2 = dot(luma, result2.xyz);\n\n\tvec4 color;\n\tif (lumaResult2 < lumaMin || lumaResult2 > lumaMax){ // teste si on est pas parti trop loin\n\t\tcolor = result1;\n\t} else {\n\t\tcolor = result2;\n\t}\n\n\t// no alpha\n\t// if (lumaResult2 < lumaMin || lumaResult2 > lumaMax){ // teste si on est pas parti trop loin\n\t// \tcolor = vec4(result1.xyz, 1.0);\n\t// } else {\n\t// \tcolor = vec4(result2.xyz, 1.0);\n\t// }\n\n\treturn color;\n}\n\nvoid main() {\n\tgl_FragColor = applyFXAA(textureMap, fragTexture, resolution);\n}\n",attributes:["position","texture"],uniforms:["flipY","textureMap","resolution"]}}}]);