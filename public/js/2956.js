"use strict";(self.webpackChunkdovotori_portfolio=self.webpackChunkdovotori_portfolio||[]).push([[2956,7719,552],{57719:(n,t,e)=>{e.r(t),e.d(t,{default:()=>a});const a="\nattribute vec3 position;\nattribute vec2 texture;\nvarying vec2 fragTexture;\nuniform float flipY; // 1 ou -1\n\nvoid main() {\n  fragTexture = texture;\n  gl_Position = vec4(position.x, position.y * flipY, position.z, 1.0);\n}\n"},2956:(n,t,e)=>{e.r(t),e.d(t,{NUM_SAMPLES:()=>r,default:()=>i});var a=e(20552),o=e(57719),r=64,f="\nprecision mediump float;\n#define NUM_SAMPLES ".concat(r,"\n").concat(a.PI,"\n\nvarying vec2 fragTexture;\n\nuniform sampler2D textureMap; // depth map\nuniform vec2 resolution;\nuniform float near;\nuniform float far;\nuniform float strength;\nuniform float radius; // 5.0\n\nfloat width = resolution.x; //texture width\nfloat height = resolution.y; //texture height\n\nfloat aoclamp = 0.125; //depth clamp - reduces haloing at screen edges\nbool noise = false; //use noise instead of pattern for sample dithering\nfloat noiseamount = 0.0002; //dithering amount\n\nfloat diffarea = 0.3; //self-shadowing reduction\nfloat gdisplace = 0.4; //gauss bell center //0.4\n\nvec2 rand(vec2 coord) {\n  float noiseX = ((fract(1.0-coord.s*(width/2.0))*0.25)+(fract(coord.t*(height/2.0))*0.75))*2.0-1.0;\n  float noiseY = ((fract(1.0-coord.s*(width/2.0))*0.75)+(fract(coord.t*(height/2.0))*0.25))*2.0-1.0;\n\n  if (noise) {\n    noiseX = clamp(fract(sin(dot(coord, vec2(12.9898,78.233))) * 43758.5453),0.0,1.0)*2.0-1.0;\n    noiseY = clamp(fract(sin(dot(coord, vec2(12.9898,78.233)*2.0)) * 43758.5453),0.0,1.0)*2.0-1.0;\n  }\n  return vec2(noiseX,noiseY)*noiseamount;\n}\n\nfloat readDepth(vec2 coord) {\n  float z_b = texture2D(textureMap, coord).x;\n  float z_n = 2.0 * z_b - 1.0;\n  return (2.0 * near) / (far + near - z_n * (far-near));\n}\n\nint compareDepthsFar(float depth1, float depth2) {\n  float garea = 2.0; //gauss bell width\n  float diff = (depth1 - depth2)*100.0; //depth difference (0-100)\n  //reduce left bell width to avoid self-shadowing\n  if (diff<gdisplace) {\n    return 0;\n  } else {\n    return 1;\n  }\n}\n\nfloat compareDepths(float depth1, float depth2) {\n  float garea = 2.0; //gauss bell width\n  float diff = (depth1 - depth2)*100.0; //depth difference (0-100)\n  //reduce left bell width to avoid self-shadowing\n  if (diff < gdisplace) {\n    garea = diffarea;\n  }\n\n  float gauss = pow(2.7182,-2.0*(diff-gdisplace)*(diff-gdisplace)/(garea*garea));\n  return gauss;\n}\n\nfloat calAO(float depth,float dw, float dh) {\n  float dd = (1.0-depth)*radius;\n\n  float temp = 0.0;\n  float temp2 = 0.0;\n  float coordw = fragTexture.x + dw*dd;\n  float coordh = fragTexture.y + dh*dd;\n  float coordw2 = fragTexture.x - dw*dd;\n  float coordh2 = fragTexture.y - dh*dd;\n\n  vec2 coord = vec2(coordw , coordh);\n  vec2 coord2 = vec2(coordw2, coordh2);\n\n  float cd = readDepth(coord);\n  int far = compareDepthsFar(depth, cd);\n  temp = compareDepths(depth, cd);\n  //DEPTH EXTRAPOLATION:\n  if (far > 0) {\n    temp2 = compareDepths(readDepth(coord2),depth);\n    temp += (1.0-temp)*temp2;\n  }\n\n  return temp;\n}\n\nvoid main(void) {\n  vec2 noise = rand(fragTexture);\n  float depth = readDepth(fragTexture);\n\n  float w = (1.0 / width)/clamp(depth,aoclamp,1.0)+(noise.x*(1.0-noise.x));\n  float h = (1.0 / height)/clamp(depth,aoclamp,1.0)+(noise.y*(1.0-noise.y));\n\n  float pw = 0.0;\n  float ph = 0.0;\n\n  float ao = 0.0;\n\n  float dl = PI * (3.0 - sqrt(5.0));\n  float dz = 1.0 / float(NUM_SAMPLES);\n  float l = 0.0;\n  float z = 1.0 - dz/2.0;\n\n  for (int i = 0; i < NUM_SAMPLES; i++) {\n    float r = sqrt(1.0 - z);\n\n    pw = cos(l) * r;\n    ph = sin(l) * r;\n    ao += calAO(depth,pw*w,ph*h);\n    z = z - dz;\n    l = l + dl;\n  }\n\n  ao /= float(NUM_SAMPLES);\n  ao *= strength;\n  ao = 1.0 - ao;\n\n  vec3 final = vec3(ao);\n  gl_FragColor = vec4(final,1.0);\n}\n");const i={vertex:o.default,fragment:f,attributes:["position","texture"],uniforms:["flipY","textureMap","radius","resolution","near","far","strength"]}},20552:(n,t,e)=>{e.r(t),e.d(t,{PI:()=>a,TWO_PI:()=>o,attributeColors:()=>r,funcGradiant:()=>d,funcGrain:()=>l,funcMap:()=>i,varyingColors:()=>f});var a="\n#define PI 3.14159265359\n",o="\n#define TWO_PI 6.28318530718\n",r="\nattribute vec3 ambiant;\nattribute vec3 diffuse;\nattribute vec3 specular;\nattribute float specDensity;\nattribute float opacity;\n",f="\nvarying vec3 fragAmbiant;\nvarying vec3 fragDiffuse;\nvarying vec3 fragSpecular;\nvarying float fragSpecDensity;\nvarying float fragOpacity;\n",i="\nfloat funcMap(float valeur, float minRef, float maxRef, float minDest, float maxDest) {\n  float result = minDest + (valeur - minRef) * (maxDest - minDest) / (maxRef - minRef);\n  if(result > maxDest){ result = maxDest; } else if(result < minDest){ result = minDest; }\n  return result;\n}\n",l="\nvec4 funcGrain(vec2 uv, float time, float strength) {\n  float x = (uv.x + 4.0 ) * (uv.y + 4.0 ) * (time * 10.0);\n  return vec4(mod((mod(x, 13.0) + 1.0) * (mod(x, 123.0) + 1.0), 0.01)-0.005) * strength;\n}\n",d="\n".concat(i,"\nvec4 funcGradiant(vec4 color1, vec4 color2, float start, float end, float uvAxe) {\n  float mixValue = funcMap(uvAxe, start, end, 0.0, 1.0);\n  return mix(color1, color2, mixValue);\n}\n")}}]);