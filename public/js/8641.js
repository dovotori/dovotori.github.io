"use strict";(self.webpackChunkdovotori=self.webpackChunkdovotori||[]).push([[8641,1014],{51014:(n,t,e)=>{e.r(t),e.d(t,{default:()=>o});const o="\nattribute vec3 position;\nattribute vec2 texture;\nvarying vec2 fragTexture;\nuniform float flipY; // 1 ou -1\n\nvoid main() {\n  fragTexture = texture;\n  gl_Position = vec4(position.x, position.y * flipY, position.z, 1.0);\n}\n"},91022:(n,t,e)=>{e.r(t),e.d(t,{default:()=>o});const o={vertex:e(51014).default,fragment:'\nprecision mediump float;\n\nuniform vec2 resolution;\nuniform float time;\n\nvarying vec2 fragTexture;\n\nmat2 rot(in float a){float c = cos(a), s = sin(a);return mat2(c,s,-s,c);}\nconst mat3 m3 = mat3(\n  0.33338, 0.56034, -0.71817,\n  -0.87887, 0.32651, -0.15323,\n  0.15162, 0.69596, 0.61339) * 1.93;\nfloat mag2(vec2 p){return dot(p,p);}\nfloat linstep(in float mn, in float mx, in float x){ return clamp((x - mn)/(mx - mn), 0., 1.); }\nfloat prm1 = 0.;\nvec2 bsMo = vec2(0);\n\nvec2 disp(float t){ return vec2(sin(t*0.22)*1., cos(t*0.175)*1.)*2.; }\n\nvec2 map(vec3 p) {\n    vec3 p2 = p;\n    p2.xy -= disp(p.z).xy;\n    p.xy *= rot(sin(p.z+time)*(0.1 + prm1*0.05) + time*0.09);\n    float cl = mag2(p2.xy);\n    float d = 0.;\n    p *= .61;\n    float z = 1.;\n    float trk = 1.;\n    float dspAmp = 0.1 + prm1*0.2;\n    for(int i = 0; i < 5; i++)\n    {\n\t\tp += sin(p.zxy*0.75*trk + time*trk*.8)*dspAmp;\n        d -= abs(dot(cos(p), sin(p.yzx))*z);\n        z *= 0.57;\n        trk *= 1.4;\n        p = p*m3;\n    }\n    d = abs(d + prm1*3.)+ prm1*.3 - 2.5 + bsMo.y;\n    return vec2(d + cl*.2 + 0.25, cl);\n}\n\nvec4 render( vec3 ro, vec3 rd, float time ) {\n\tvec4 rez = vec4(0);\n    const float ldst = 8.;\n\tvec3 lpos = vec3(disp(time + ldst)*0.5, time + ldst);\n\tfloat t = 1.5;\n\tfloat fogT = 0.;\n\tfor(int i=0; i<130; i++)\n\t{\n\t\tif(rez.a > 0.99)break;\n\n\t\tvec3 pos = ro + t*rd;\n        vec2 mpv = map(pos);\n\t\tfloat den = clamp(mpv.x-0.3,0.,1.)*1.12;\n\t\tfloat dn = clamp((mpv.x + 2.),0.,3.);\n        \n\t\tvec4 col = vec4(0);\n        if (mpv.x > 0.6)\n        {\n        \n            col = vec4(sin(vec3(5.,0.4,0.2) + mpv.y*0.1 +sin(pos.z*0.4)*0.5 + 1.8)*0.5 + 0.5,0.08);\n            col *= den*den*den;\n\t\t\tcol.rgb *= linstep(4.,-2.5, mpv.x)*2.3;\n            float dif =  clamp((den - map(pos+.8).x)/9., 0.001, 1. );\n            dif += clamp((den - map(pos+.35).x)/2.5, 0.001, 1. );\n            col.xyz *= den*(vec3(0.005,.045,.075) + 1.5*vec3(0.033,0.07,0.03)*dif);\n        }\n\t\t\n\t\tfloat fogC = exp(t*0.2 - 2.2);\n\t\tcol.rgba += vec4(0.06,0.11,0.11, 0.1)*clamp(fogC-fogT, 0., 1.);\n\t\tfogT = fogC;\n\t\trez = rez + col*(1. - rez.a);\n\t\tt += clamp(0.5 - dn*dn*.05, 0.09, 0.3);\n\t}\n\treturn clamp(rez, 0.0, 1.0);\n}\n\nfloat getsat(vec3 c)\n{\n    float mi = min(min(c.x, c.y), c.z);\n    float ma = max(max(c.x, c.y), c.z);\n    return (ma - mi)/(ma+ 1e-7);\n}\n\n//from my "Will it blend" shader (https://www.shadertoy.com/view/lsdGzN)\nvec3 lerp(vec3 a, vec3 b, float x) {\n    vec3 ic = mix(a, b, x) + vec3(1e-6,0.,0.);\n    float sd = abs(getsat(ic) - mix(getsat(a), getsat(b), x));\n    vec3 dir = normalize(vec3(2.*ic.x - ic.y - ic.z, 2.*ic.y - ic.x - ic.z, 2.*ic.z - ic.y - ic.x));\n    float lgt = dot(vec3(1.0), ic);\n    float ff = dot(dir, normalize(ic));\n    ic += 1.5*dir*sd*ff*lgt;\n    return clamp(ic,0.,1.);\n}\n\nvoid main() {\t\n\tvec2 q = fragTexture.xy / resolution.xy;\n  vec2 p = (fragTexture.xy - 0.5*resolution.xy)/resolution.y;\n  // bsMo = (iMouse.xy - 0.5*resolution.xy)/resolution.y;\n  bsMo = vec2(0.5,0.5);\n  \n  float time = time*3.;\n  vec3 ro = vec3(0,0,time);\n  \n  ro += vec3(sin(time)*0.5,sin(time*1.)*0.,0);\n      \n  float dspAmp = .85;\n  ro.xy += disp(ro.z)*dspAmp;\n  float tgtDst = 3.5;\n  \n  vec3 target = normalize(ro - vec3(disp(time + tgtDst)*dspAmp, time + tgtDst));\n  ro.x -= bsMo.x*2.;\n  vec3 rightdir = normalize(cross(target, vec3(0,1,0)));\n  vec3 updir = normalize(cross(rightdir, target));\n  rightdir = normalize(cross(updir, target));\n\tvec3 rd=normalize((p.x*rightdir + p.y*updir)*1. - target);\n  rd.xy *= rot(-disp(time + 3.5).x*0.2 + bsMo.x);\n  prm1 = smoothstep(-0.4, 0.4,sin(time*0.3));\n\tvec4 scn = render(ro, rd, time);\n\t\t\n  vec3 col = scn.rgb;\n  col = lerp(col.bgr, col.rgb, clamp(1.-prm1,0.05,1.));\n  \n  col = pow(col, vec3(.55,0.65,0.6))*vec3(1.,.97,.9);\n\n  col *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.12)*0.7+0.3; //Vign\n    \n\tgl_FragColor = vec4( col, 1.0 );\n}\n',attributes:["position","texture"],uniforms:["flipY","resolution","time"]}}}]);