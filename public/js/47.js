(window.webpackJsonp=window.webpackJsonp||[]).push([[47,105],{195:function(n,o,a){"use strict";a.r(o),a.d(o,"funcShadow",(function(){return r})),a.d(o,"uniformVertShadow",(function(){return e})),a.d(o,"uniformFragShadow",(function(){return i})),a.d(o,"shadowLocations",(function(){return t}));var r="\nfloat funcShadow(\n  vec4 pos, \n  vec2 resolution, \n  float lambertCosinus\n) {\n  if (pos.z > 1.0) {\n    return 1.0; // outside light frustum, ignore\n  }\n\n  float bias = max(shadowEpsilon * (1.0 - lambertCosinus), shadowEpsilon * 0.01);\n  vec2 texelSize = 1.0 / resolution;\n\n  // PCF (percentage closer filter)\n  float shadow = 0.0;\n  for(float y = -1.0; y <= 1.0; y += 1.0) {\n    for(float x = -1.0; x <= 1.0; x += 1.0) {\n      float depth = texture2D(shadowMap, pos.xy + vec2(x,y) * texelSize).r;\n      shadow += (depth + bias) < pos.z ? 0.0 : 1.0;\n    } \n  }\n  shadow /= 9.0;\n  return (shadow * lambertCosinus) + lighten;\n}\n",e="\nuniform mat4 shadowView;\nuniform mat4 shadowProjection;\n\nconst mat4 bias = mat4(\n  0.5, 0.0, 0.0, 0.0,\n  0.0, 0.5, 0.0, 0.0,\n  0.0, 0.0, 0.5, 0.0,\n  0.5, 0.5, 0.5, 1.0\n);\n",i="\nuniform sampler2D shadowMap;\nuniform float shadowEpsilon;\nuniform float lighten;\nuniform vec3 posLum;\n",t=["shadowView","shadowProjection","shadowMap","lighten","posLum"]},222:function(n,o,a){"use strict";a.r(o);var r=a(195),e="\nattribute vec3 position;\nattribute vec3 normale;\nattribute vec2 texture;\n\nuniform mat4 projection;\nuniform mat4 view;\nuniform mat4 model;\nuniform mat3 normalMatrix;\n\n".concat(r.uniformVertShadow,"\n\nvarying vec3 fragPosition;\nvarying vec4 fragShadow;\nvarying vec3 fragNormale;\nvarying vec2 fragTexture;\n\nvoid main() {\n  fragShadow = bias * shadowProjection * shadowView * model * vec4(position, 1.0);\n  fragNormale = normalMatrix * normale;\n  fragTexture = texture;\n  fragPosition = normalize((view * model * vec4(position, 1.0)).xyz);\n  gl_Position = projection * view * model * vec4(position, 1.0);\n}\n"),i="\nprecision mediump float;\n\n".concat(r.uniformFragShadow,"\n\nuniform vec2 resolution;\n\nvarying vec3 fragPosition;\nvarying vec4 fragShadow;\nvarying vec3 fragNormale;\nvarying vec2 fragTexture;\n\n").concat(r.funcShadow,"\n\nvoid main() {\n  vec3 N = normalize(fragNormale);\n  vec3 L = normalize(posLum - fragPosition);\n  float lambertCosinus = max(dot(N, L), 0.0);\n  \n  float shadow = funcShadow(fragShadow, resolution, lambertCosinus);\n  gl_FragColor = vec4(vec3(shadow), 1.0);\n}\n");o.default={vertex:e,fragment:i,attributes:["position","texture","normale"],uniforms:["projection","model","view","normalMatrix","resolution"].concat(r.shadowLocations)}}}]);