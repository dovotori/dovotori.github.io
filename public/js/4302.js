"use strict";(self.webpackChunkdovotori=self.webpackChunkdovotori||[]).push([[4302,552],{74516:(n,t,e)=>{e.r(t),e.d(t,{default:()=>o});var a=e(20552);const o={vertex:"\nattribute float index;\nattribute float offset;\nuniform mat4 projection;\nuniform mat4 model;\nuniform mat4 view;\nuniform int maxfrequency;\nuniform int length;\nuniform int count;\nuniform float time;\nuniform vec2 mouse;\n\n".concat(a.funcMap,"\n").concat(a.PI,"\n\n#define SIZE 1.0\n\nvarying vec4 color;\n\nvoid main() {\n  float radian = funcMap(index, 0.0, float(length), 0.0, PI * 2.0);\n  \n  float amplitude = 0.05;\n  float speed = funcMap(offset, 0.0, float(count), 4.0, 10.0);\n  float shapeX = 0.6 * mouse.x;\n  float shapeY = 0.4 * mouse.y;\n  float variation = sin(index * shapeX + time * speed) * amplitude;\n  variation += cos(index * shapeY + time * speed) * amplitude;\n  // variation *= mouse.x;\n  // variation *= 0.5 + funcMap(offset, 0.0, float(count), -.5, .5);\n\n  float x = cos(radian) * (SIZE + variation);\n  float y = sin(radian) * (SIZE + variation);\n  float z = offset * mouse.x * 0.1;\n\n  vec3 position = vec3(x, y, z);\n  float opacity = funcMap(offset, 0.0, float(count), 0.0, 1.0);\n  color = vec4(1.0 - y, .8, 1.0, 1.0 - opacity);\n  \n  gl_Position = projection * view * model * vec4(position, 1.0);\n}\n"),fragment:"\nprecision mediump float;\n\nvarying vec4 color;\n\nvoid main() {\n  gl_FragColor = color;\n}\n",attributes:["index","offset"],uniforms:["projection","model","view","length","count","time","mouse"]}},20552:(n,t,e)=>{e.r(t),e.d(t,{PI:()=>a,TWO_PI:()=>o,attributeColors:()=>i,funcGradiant:()=>u,funcGrain:()=>l,funcMap:()=>r,varyingColors:()=>f});var a="\n#define PI 3.14159265359\n",o="\n#define TWO_PI 6.28318530718\n",i="\nattribute vec3 ambiant;\nattribute vec3 diffuse;\nattribute vec3 specular;\nattribute float specDensity;\nattribute float opacity;\n",f="\nvarying vec3 fragAmbiant;\nvarying vec3 fragDiffuse;\nvarying vec3 fragSpecular;\nvarying float fragSpecDensity;\nvarying float fragOpacity;\n",r="\nfloat funcMap(float valeur, float minRef, float maxRef, float minDest, float maxDest) {\n  float result = minDest + (valeur - minRef) * (maxDest - minDest) / (maxRef - minRef);\n  if(result > maxDest){ result = maxDest; } else if(result < minDest){ result = minDest; }\n  return result;\n}\n",l="\nvec4 funcGrain(vec2 uv, float time, float strength) {\n  float x = (uv.x + 4.0 ) * (uv.y + 4.0 ) * (time * 10.0);\n  return vec4(mod((mod(x, 13.0) + 1.0) * (mod(x, 123.0) + 1.0), 0.01)-0.005) * strength;\n}\n",u="\n".concat(r,"\nvec4 funcGradiant(vec4 color1, vec4 color2, float start, float end, float uvAxe) {\n  float mixValue = funcMap(uvAxe, start, end, 0.0, 1.0);\n  return mix(color1, color2, mixValue);\n}\n")}}]);