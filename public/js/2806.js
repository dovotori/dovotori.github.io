"use strict";(self.webpackChunkdovotori_portfolio=self.webpackChunkdovotori_portfolio||[]).push([[2806,7719,552],{57719:(n,e,t)=>{t.r(e),t.d(e,{default:()=>r});const r="\nattribute vec3 position;\nattribute vec2 texture;\nvarying vec2 fragTexture;\nuniform float flipY; // 1 ou -1\n\nvoid main() {\n  fragTexture = texture;\n  gl_Position = vec4(position.x, position.y * flipY, position.z, 1.0);\n}\n"},2806:(n,e,t)=>{t.r(e),t.d(e,{default:()=>o});var r=t(20552),i=t(57719),a="\nprecision mediump float;\n\nuniform sampler2D textureMap;\nuniform float time;\n\nvarying vec2 fragTexture;\n\n".concat(r.PI,"\n").concat("\nvec3 camera(vec3 rayOrigin, vec2 uv) {\n  vec3 lookAtPoint = vec3(0.);\n  float zoom = 1.;\n\n  vec3 forward = normalize(lookAtPoint - rayOrigin);\n  vec3 right = cross(vec3(0.,1.,0.), forward);\n  vec3 up = cross(forward, right);\n\n  vec3 center = rayOrigin + forward * zoom;\n  vec3 intersect = center + uv.x * right + uv.y * up;\n\n  return intersect - rayOrigin; // between eye pos and screen position\n}\n\n","\n\nfloat getSceneDist(vec3 point) {\n  vec3 spherePosition = vec3(0., 1., 2.);\n  float sphereRadius = 0.5;\n\n  float sphereDistance = length(point - spherePosition) - sphereRadius;\n  \n  float planeY = -0.4;\n  float planeDistance = point.y - planeY;\n\n  float d = min(sphereDistance, planeDistance);\n  return d;\n}\n\n").concat("\n#define RAY_MARCH_MAX_STEPS 100\n#define RAY_MARCH_MAX_DIST 100.\n#define RAY_MARCH_SURF_DIST .01 // distance where we have a hit\n\nfloat rayMarch(vec3 ro, vec3 rd) {\n\tfloat dO = 0.;\n  for(int i=0; i<RAY_MARCH_MAX_STEPS; i++) {\n    vec3 p = ro + rd*dO;\n    float dS = getSceneDist(p);\n    dO += dS;\n    if(dO > RAY_MARCH_MAX_DIST || dS < RAY_MARCH_SURF_DIST) break;\n  }  \n  return dO;\n}\n","\n\nvec3 getNormale(vec3 p) {\n  float distance = getSceneDist(p);\n  vec2 threshold = vec2(.01, 0.);\n  vec3 normale = distance - vec3(\n    getSceneDist(p - threshold.xyy),\n    getSceneDist(p - threshold.yxy),\n    getSceneDist(p - threshold.yyx)\n  );\n  return normalize(normale);\n}\n\nfloat getLight(vec3 p) {\n  vec3 lightPos = vec3(0.,5.,-1.);\n  vec3 lightDir = normalize(lightPos - p);\n  vec3 normale = getNormale(p);\n  float diffuse = clamp(dot(normale, lightDir), 0., 1.);\n\n  // shadow\n  float distranceToLight = rayMarch(p + normale * 0.02, lightDir);\n  if (distranceToLight < length(lightPos - p)) {\n    diffuse *= .1;\n  }\n  return diffuse;\n}\n\nvoid main() {\n  vec2 uv = fragTexture - 0.5; \n\n  vec3 rayOrigin = vec3(0., 1., -4.); // eye pos\n  vec3 rayDirection = camera(rayOrigin, uv);\n\n  float d = rayMarch(rayOrigin, rayDirection);\n  // d /= 6.; // distance is > 1 so we need to lower this arbitrarely\n\n  vec3 p = rayOrigin + rayDirection * d;\n\n\tgl_FragColor = vec4(vec3(getLight(p)), 1.0);\n}\n");const o={vertex:i.default,fragment:a,attributes:["position","texture"],uniforms:["flipY","textureMap","time"]}},20552:(n,e,t)=>{t.r(e),t.d(e,{PI:()=>r,TWO_PI:()=>i,attributeColors:()=>a,funcGradiant:()=>f,funcGrain:()=>l,funcMap:()=>c,varyingColors:()=>o});var r="\n#define PI 3.14159265359\n",i="\n#define TWO_PI 6.28318530718\n",a="\nattribute vec3 ambiant;\nattribute vec3 diffuse;\nattribute vec3 specular;\nattribute float specDensity;\nattribute float opacity;\n",o="\nvarying vec3 fragAmbiant;\nvarying vec3 fragDiffuse;\nvarying vec3 fragSpecular;\nvarying float fragSpecDensity;\nvarying float fragOpacity;\n",c="\nfloat funcMap(float valeur, float minRef, float maxRef, float minDest, float maxDest) {\n  float result = minDest + (valeur - minRef) * (maxDest - minDest) / (maxRef - minRef);\n  if(result > maxDest){ result = maxDest; } else if(result < minDest){ result = minDest; }\n  return result;\n}\n",l="\nvec4 funcGrain(vec2 uv, float time, float strength) {\n  float x = (uv.x + 4.0 ) * (uv.y + 4.0 ) * (time * 10.0);\n  return vec4(mod((mod(x, 13.0) + 1.0) * (mod(x, 123.0) + 1.0), 0.01)-0.005) * strength;\n}\n",f="\n".concat(c,"\nvec4 funcGradiant(vec4 color1, vec4 color2, float start, float end, float uvAxe) {\n  float mixValue = funcMap(uvAxe, start, end, 0.0, 1.0);\n  return mix(color1, color2, mixValue);\n}\n")}}]);