"use strict";(self.webpackChunkdovotori=self.webpackChunkdovotori||[]).push([[2093],{66121:(e,t,i)=>{i.d(t,{BJ:()=>n,Tq:()=>r,YM:()=>s,k6:()=>a});const r={CAMERA:0,TRANSFORM:1,MATERIAL:2,LIGHT:3},s=e=>{const t=e.createBindGroupLayout({label:"Camera Uniform Bind Group Layout",entries:[{binding:0,visibility:GPUShaderStage.VERTEX,buffer:{type:"uniform",hasDynamicOffset:!1,minBindingSize:208}},{binding:1,visibility:GPUShaderStage.VERTEX,buffer:{type:"uniform",hasDynamicOffset:!1}}]}),i=e.createBindGroupLayout({label:"Transform Uniform Bind Group Layout",entries:[{binding:0,visibility:GPUShaderStage.VERTEX,buffer:{type:"uniform",hasDynamicOffset:!1}}]}),s=e.createBindGroupLayout({label:"Material Uniform Bind Group Layout",entries:[{binding:0,visibility:GPUShaderStage.FRAGMENT,buffer:{type:"uniform",hasDynamicOffset:!1,minBindingSize:48}},{binding:1,visibility:GPUShaderStage.FRAGMENT,sampler:{}},{binding:2,visibility:GPUShaderStage.FRAGMENT,texture:{}},{binding:3,visibility:GPUShaderStage.FRAGMENT,sampler:{type:"comparison"}},{binding:4,visibility:GPUShaderStage.FRAGMENT,texture:{sampleType:"depth",viewDimension:"2d"}},{binding:5,visibility:GPUShaderStage.FRAGMENT,buffer:{type:"uniform"}}]}),a=e.createBindGroupLayout({label:"Lights Storage Bind Group Layout",entries:[{binding:0,visibility:GPUShaderStage.FRAGMENT,buffer:{type:"read-only-storage",hasDynamicOffset:!1,minBindingSize:0}}]});return{[r.CAMERA]:t,[r.TRANSFORM]:i,[r.MATERIAL]:s,[r.LIGHT]:a}},a=e=>[e.createBindGroupLayout({label:"Shadow Camera Uniform Bind Group Layout",entries:[{binding:0,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,buffer:{type:"uniform",hasDynamicOffset:!1,minBindingSize:208}}]}),e.createBindGroupLayout({label:"Shadow Transform Uniform Bind Group Layout",entries:[{binding:0,visibility:GPUShaderStage.VERTEX,buffer:{type:"uniform",hasDynamicOffset:!1,minBindingSize:112}}]})],n=e=>[e.createBindGroupLayout({label:"Picking Camera Uniform Bind Group Layout",entries:[{binding:0,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,buffer:{type:"uniform",hasDynamicOffset:!1,minBindingSize:208}}]}),e.createBindGroupLayout({label:"Picking Transform Uniform Bind Group Layout",entries:[{binding:0,visibility:GPUShaderStage.VERTEX,buffer:{type:"uniform",hasDynamicOffset:!1,minBindingSize:128}}]})]},28649:(e,t,i)=>{i.d(t,{a:()=>r});const r={color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{srcFactor:"one",dstFactor:"one"}}},92093:(e,t,i)=>{i.r(t),i.d(t,{Buffer:()=>s,BufferGltf:()=>a,BufferMaterial:()=>n,BufferTransform:()=>p,Context:()=>b.A,DebugTexture:()=>D,Device:()=>x,GltfBindGroups:()=>G.Tq,GltfPipeline:()=>R,Picking:()=>M,Pipeline:()=>g,PipelineTextures:()=>T,Program:()=>m,Shadow:()=>C,buildBindGroupLayouts:()=>G.YM,buildPickingBindGroupLayouts:()=>G.BJ,buildShadowBindGroupLayouts:()=>G.k6,getNodePickingColor:()=>S,pixelToPickingColor:()=>v});var r=i(54705);const s=class{constructor(){(0,r.A)(this,"get",(()=>this.buffers)),(0,r.A)(this,"getLayout",(()=>this.layout)),(0,r.A)(this,"getIndexCount",(()=>this.indexCount)),this.buffers={vertex:null,index:null},this.layout=null}setup(e,t){const{indices:i,position:r}=t;this.indexCount=i.count,this.buffers.vertex=e.createBuffer({label:"vertex buffer",size:r.values.byteLength,usage:window.GPUBufferUsage.VERTEX|window.GPUBufferUsage.COPY_DST}),this.buffers.index=e.createBuffer({label:"index buffer",size:i.values.byteLength,usage:window.GPUBufferUsage.INDEX|window.GPUBufferUsage.COPY_DST}),e.queue.writeBuffer(this.buffers.vertex,0,r.values),e.queue.writeBuffer(this.buffers.index,0,i.values),this.layout={arrayStride:12,attributes:[{format:"float32x3",offset:0,shaderLocation:0}]}}};const a=class{constructor(){(0,r.A)(this,"setupFaceColorPick",((e,t)=>{this.faceColor=e.createBuffer({label:"face color buffer",size:Float32Array.BYTES_PER_ELEMENT*t.length,mappedAtCreation:!0,usage:window.GPUBufferUsage.VERTEX|window.GPUBufferUsage.COPY_DST});new Float32Array(this.faceColor.getMappedRange()).set(t),this.faceColor.unmap()})),(0,r.A)(this,"getFaceBuffer",(()=>this.faceBuffer)),(0,r.A)(this,"getFaceBufferCount",(()=>this.faceDrawCount)),(0,r.A)(this,"getVertexBuffer",(()=>this.vertex)),(0,r.A)(this,"getIndexBuffer",(()=>this.indexes)),(0,r.A)(this,"getFaceColorBuffer",(()=>this.faceColor)),(0,r.A)(this,"getLayout",(()=>this.layout)),(0,r.A)(this,"getIndexCount",(()=>this.indexCount)),this.vertex=null,this.indexes=null,this.layout=null,this.faceColor=null}setup(e,t){const{arrayStride:i,attributes:r,bufferVertex:s,bufferIndex:a,indexCount:n}=t;this.indexCount=n,this.vertex=e.createBuffer({label:"vertex buffer",size:4*Math.ceil(s.byteLength/4),mappedAtCreation:!0,usage:window.GPUBufferUsage.VERTEX|window.GPUBufferUsage.COPY_DST});new Float32Array(this.vertex.getMappedRange()).set(new Float32Array(s,0,this.vertex.byteLength)),this.vertex.unmap(),this.indexes=e.createBuffer({label:"index buffer",size:4*Math.ceil(a.byteLength/4),mappedAtCreation:!0,usage:window.GPUBufferUsage.INDEX|window.GPUBufferUsage.COPY_DST});new Uint16Array(this.indexes.getMappedRange()).set(new Uint16Array(a,0,this.indexes.byteLength)),this.indexes.unmap(),this.layout={arrayStride:i,attributes:r}}setupForFaces(e,t,i){const{arrayStride:r,bufferVertex:s,bufferIndex:a,indexCount:n}=t,o=r/Float32Array.BYTES_PER_ELEMENT,u=new Map;let l=0;for(let e=0;e<s.length;e+=o,l++)u.set(l,s.slice(e,e+o));const h=[];a.forEach(((e,t)=>{const r=i[t],s=[...u.get(e),r];h.push(...s)}));const d=new Float32Array(h);this.faceBuffer=e.createBuffer({label:"vertex buffer per face",size:4*Math.ceil(d.byteLength/4),mappedAtCreation:!0,usage:window.GPUBufferUsage.VERTEX|window.GPUBufferUsage.COPY_DST});new Float32Array(this.faceBuffer.getMappedRange()).set(new Float32Array(d,0,this.faceBuffer.byteLength)),this.faceBuffer.unmap(),this.faceDrawCount=n}};const n=class{constructor(){(0,r.A)(this,"getBindGroups",(()=>this.bindGroups)),(0,r.A)(this,"getBindGroup",(e=>this.bindGroups.get(e))),this.bindGroups=new Map}async setup(e,t,i,r,s){const a=await this.setupEmptyTexture(e);let n=0;for(let[o,u]of i){const i=[{binding:0,resource:{buffer:this.setupUniformsBuffer(e,u)}}];if(u.pbrMetallicRoughness.baseColorTexture){const t=r.get(u.pbrMetallicRoughness.baseColorTexture.index),{sampler:s,textureView:a}=this.setupTexture(e,t);i.push({binding:1,resource:s},{binding:2,resource:a})}else i.push({binding:1,resource:a.sampler},{binding:2,resource:a.textureView});i.push(...s),this.bindGroups.set(n,e.createBindGroup({label:"bind group material",layout:t,entries:i})),n++}}setupUniformsBuffer(e,t){const i=e.createBuffer({size:12*Float32Array.BYTES_PER_ELEMENT,usage:window.GPUBufferUsage.UNIFORM|window.GPUBufferUsage.COPY_DST,mappedAtCreation:!0}),r=new Float32Array(i.getMappedRange()),s=[...t.pbrMetallicRoughness?.baseColorFactor||[1,1,1,1],...t.emissiveFactor||[1,1,1],t.pbrMetallicRoughness?.metallicFactor??.5,t.pbrMetallicRoughness?.roughnessFactor??.5];return r.set(s),i.unmap(),i}setupTexture(e,t){const i=[t.imageData.width,t.imageData.height],r=e.createTexture({label:"Material base color texture",size:i,format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT});return e.queue.copyExternalImageToTexture({source:t.imageData},{texture:r},i),{sampler:e.createSampler({addressModeU:"repeat",addressModeV:"repeat",magFilter:"linear",minFilter:"nearest",mipmapFilter:"nearest",maxAnisotropy:1}),textureView:r.createView({format:"rgba8unorm",dimension:"2d",aspect:"all"})}}async setupEmptyTexture(e){const t=new ImageData(1,1);t.data[0]=255,t.data[1]=0,t.data[2]=0,t.data[3]=255;const i=await createImageBitmap(t),r=[t.width,t.height],s=e.createTexture({label:"Material empty texture",size:r,format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT});return e.queue.copyExternalImageToTexture({source:i},{texture:s},r),{sampler:e.createSampler(),textureView:s.createView()}}};var o,u=i(2823),l=i(27853);class h{}o=h,(0,r.A)(h,"get",(e=>o.handleLocalTransform(e))),(0,r.A)(h,"getNormalMatrix",(e=>{const t=e.getMatrice3x3();return t.inverse(),t.transpose(),t})),(0,r.A)(h,"handleLocalTransform",(e=>{const{translation:t,rotation:i,scale:r,matrix:s}=e,a=new l.A;return a.identity(),r&&a.scale(...r),i&&a.multiply(new u.A(...i).toMatrix4()),t&&a.translate(...t),s&&a.multiplyArray(s),a}));const d=h;class c{static setup(e,t,i,r){const s=c.setupOne(e,i,r);return e.createBindGroup({label:"NodeTransformBindGroup",layout:t,entries:[{binding:0,resource:{buffer:s}}]})}static setupOne(e,t,i){const{transformMatrix:r,pickingColor:s}=t,a=e.createBuffer({size:16*Float32Array.BYTES_PER_ELEMENT*2,usage:window.GPUBufferUsage.UNIFORM|window.GPUBufferUsage.COPY_DST,mappedAtCreation:!0}),n=new Float32Array(a.getMappedRange()),o=d.getNormalMatrix(r).get(),u=[o[0],o[1],o[2],0,o[3],o[4],o[5],0,o[6],o[7],o[8],0],l=[...r.get(),...u,...s??[]];return n.set(l),a.unmap(),a}}const p=c;var f=i(28649);const g=class{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:4,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"depth32float";(0,r.A)(this,"setupRenderPassDescriptor",(()=>{this.renderPassDescriptor={label:"Gltf Pass Descriptor",colorAttachments:[{view:null,resolveTarget:null,clearValue:{r:0,g:0,b:0,a:0},loadOp:"clear",storeOp:"store"}],depthStencilAttachment:{view:null,depthClearValue:1,depthLoadOp:"clear",depthStoreOp:"store",stencilClearValue:0}}})),(0,r.A)(this,"update",((e,t,i)=>{this.renderPassDescriptor.colorAttachments[0].resolveTarget=e,this.renderPassDescriptor.colorAttachments[0].view=t,this.renderPassDescriptor.depthStencilAttachment.view=i})),(0,r.A)(this,"get",(()=>this.pipeline)),(0,r.A)(this,"getRenderPassDescriptor",(()=>this.renderPassDescriptor)),(0,r.A)(this,"getDepthTextureFormat",(()=>this.depthTextureFormat)),this.pipeline=null,this.renderPassDescriptor=null,this.depthTextureFormat=t,this.sampleCount=e}async setup(e,t,i,r,s,a){const n={label:"Gltf pipeline",layout:e.createPipelineLayout({label:"Pipeline layout",bindGroupLayouts:a}),vertex:{module:t.vertex,entryPoint:"v_main",buffers:r},fragment:{module:t.fragment,entryPoint:"f_main",targets:[{format:s,blend:f.a}]},primitive:i,depthStencil:{depthWriteEnabled:!0,depthCompare:"less",format:this.depthTextureFormat},multisample:{count:this.sampleCount}};this.pipeline=await e.createRenderPipelineAsync(n)}};const m=class{constructor(){(0,r.A)(this,"get",(()=>this.program)),this.program=null}setup(e,t,i){this.program=e.createShaderModule({label:t,code:i})}};const x=class{constructor(){(0,r.A)(this,"get",(()=>this.device)),(0,r.A)(this,"getEncodeur",(()=>this.encoder)),this.device=null,this.encoder=null}async setup(e){this.device=await e.requestDevice(),this.encoder=this.device.createCommandEncoder()}};var b=i(68711);const T=class{constructor(){var e=this;let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:4;(0,r.A)(this,"resize",(function(t,i,r){let s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"depth32float";e.renderTarget.destroy(),e.depthTexture.destroy(),e.setup(t,i,r,s)})),(0,r.A)(this,"setupRender",((e,t,i)=>{let{width:r,height:s}=i;this.renderTarget=e.createTexture({size:[r,s],sampleCount:this.sampleCount,format:t,usage:GPUTextureUsage.RENDER_ATTACHMENT}),this.renderTargetView=this.renderTarget.createView({label:"SceneTextureView"})})),(0,r.A)(this,"setupDepth",((e,t,i)=>{let{width:r,height:s}=i;this.depthTexture=e.createTexture({size:[r,s],sampleCount:this.sampleCount,format:t,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING}),this.depthTextureView=this.depthTexture.createView({label:"SceneDepthTextureView"})})),(0,r.A)(this,"getRenderTargetView",(()=>this.renderTargetView)),(0,r.A)(this,"getDepthTextureView",(()=>this.depthTextureView)),this.renderTarget=null,this.renderTargetView=null,this.depthTexture=null,this.depthTextureView=null,this.sampleCount=t}setup(e,t,i){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"depth32float";this.setupRender(e,t,i),this.setupDepth(e,r,i)}};var A=i(9828),y=i(50583),w=i(60717);class P{constructor(e,t){let i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;(0,r.A)(this,"addAllAnimations",((e,t,i)=>{for(const[r,s]of e){const e=t.get(r);this.nodeTramsforms.set(r,{scale:e.scale,rotation:e.rotation,translation:e.translation}),this.animations.set(r,this.addAnimations(s,i))}})),(0,r.A)(this,"addAnimations",((e,t)=>{const i=new Map;return e.forEach((e=>{let{path:r,times:s,output:a,interpolation:n}=e,o=null!==t?a[t]:a[0];"rotation"===r&&(o=new u.A(...o).toMatrix4()),this.animationInterval[1]=Math.max(...s,this.animationInterval[1]),i.set(r,{output:a,sample:new w.A(s,n,this.speedAnimation),customStep:t,value:o})})),i})),(0,r.A)(this,"update",(e=>{const t=e-this.lastFrame;t>this.animationInterval[1]*this.speedAnimation&&(this.lastFrame=e),this.updateAnimations(t)})),(0,r.A)(this,"updateAnimations",(e=>{for(const[t,i]of this.animations){const r=new Map;for(const[t,s]of i)"rotation"===t?r.set(t,P.updateQuat(s,e)):r.set(t,P.updateVector(s,e));this.animations.set(t,r)}})),(0,r.A)(this,"handleLocalTransform",(e=>{const{translation:t,rotation:i,scale:r}=this.nodeTramsforms.get(e),s=this.animations.get(e),a=s?.get("rotation")||null,n=s?.get("translation")||null,o=s?.get("scale")||null,u=new l.A;return u.identity(),(r||o)&&u.scale(...P.getVector(r,o)),(i||a)&&u.multiply(P.getRotationMat(i,a)),(t||n)&&u.translate(...P.getVector(t,n)),u})),(0,r.A)(this,"setAnimationStep",((e,t,i)=>{const r=this.animations[e][t],s=r.output.length,a=(0,y.cy)(i,0,1,0,s-1);r.customStep=Math.round(a)})),(0,r.A)(this,"setAnimationSpeed",((e,t,i)=>{this.animations[e][t].sample.setSpeed(i)})),(0,r.A)(this,"isNodeHasAnimation",(e=>this.animations.has(e))),this.speedAnimation=2e3,this.animationInterval=[0,0],this.animations=new Map,this.nodeTramsforms=new Map,this.lastFrame=0,this.addAllAnimations(e,t,i)}}(0,r.A)(P,"updateVector",((e,t)=>{const i=e,{sample:r,customStep:s,output:a}=i;if(null===s){r.update(t);const e=r.getIndex();if(0===e)[i.value]=a;else if(e>a.length-1)i.value=a[a.length-1];else{const t=a[e-1],s=a[e],n=r.get();i.value=t.map(((e,t)=>(0,A.Cc)(n,e,s[t])))}}else i.value=a[s];return i})),(0,r.A)(P,"updateQuat",((e,t)=>{const i=e,{sample:r,customStep:s,output:a}=i;if(null===s){r.update(t);const e=r.getIndex();if(0===e)i.value=new u.A(...a[0]).toMatrix4();else if(e>a.length-1)i.value=new u.A(...a[a.length-1]).toMatrix4();else{const t=a[e-1],s=a[e],n=r.get();i.value=u.A.slerpArray(t,s,n).toMatrix4()}}else i.value=new u.A(...a[s]).toMatrix4();return i})),(0,r.A)(P,"getVector",(function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[0,0,0],t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return t&&t.value?t.value:e})),(0,r.A)(P,"getRotationMat",(function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[0,0,0,1],t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return t&&t.value?t.value:new u.A(...e).toMatrix4()}));const B=P;var G=i(66121);class M{constructor(e){(0,r.A)(this,"render",(e=>{const t=this.context.getDevice(),i=t.createCommandEncoder({label:"PickingCommandEncoder"});this.renderPassDescriptor.colorAttachments[0].view=this.colorTexture.createView(),this.renderPassDescriptor.depthStencilAttachment.view=this.depthTexture.createView();const r=i.beginRenderPass(this.renderPassDescriptor);r.setPipeline(this.pipeline),r.setBindGroup(G.Tq.CAMERA,e),this.drawModel&&this.drawModel(t,r),r.end(),t.queue.submit([i.finish()])})),(0,r.A)(this,"pick",(async(e,t,i,r)=>{const s=this.context.getDevice(),a=s.createCommandEncoder({label:"PickingCommandEncoder"});this.renderPassDescriptor.colorAttachments[0].view=this.colorTexture.createView(),this.renderPassDescriptor.depthStencilAttachment.view=this.depthTexture.createView();const n=a.beginRenderPass(this.renderPassDescriptor);n.setPipeline(this.pipeline),n.setBindGroup(G.Tq.CAMERA,t),this.drawModel(s,n,i,r),n.end();const o=await this.capturePixel(e,a);return s.queue.submit([a.finish()]),o})),(0,r.A)(this,"capturePixel",(async(e,t)=>{t.copyTextureToBuffer({texture:this.colorTexture,origin:e},{buffer:this.destinationBuffer,bytesPerRow:256},{width:1,height:1}),await this.destinationBuffer.mapAsync(GPUMapMode.READ,0,this.bufferSize);const i=[...new Float32Array(this.destinationBuffer.getMappedRange(0,this.bufferSize))];return this.destinationBuffer.unmap(),[S(i[0]),S(i[1]),0,1]})),(0,r.A)(this,"drawModel",((e,t,i,r)=>{for(const[e,r]of i)r.buffers.forEach((i=>{let r=this.transformBinGroups.get(e);r&&(t.setBindGroup(G.Tq.TRANSFORM,r),t.setVertexBuffer(0,i.getFaceBuffer()),t.draw(i.getFaceBufferCount()))}))})),(0,r.A)(this,"resize",(e=>{this.textures.resize(this.context.getDevice(),this.context.getCanvasFormat(),e),this.createTexture(e),this.texSize=e})),(0,r.A)(this,"getBindGroupLayout",(e=>this.pipeline.getBindGroupLayout(e))),(0,r.A)(this,"getColorTexture",(()=>this.colorTexture)),this.context=e,this.bufferSize=16,this.pipeline=void 0,this.colorTexture=void 0,this.textures=new T,this.texSize={width:1,height:1}}createTexture(e){const t=this.context.getDevice();this.colorTexture=t.createTexture({label:"picking texture",format:"rgba32float",size:e,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC}),this.depthTexture=t.createTexture({label:"picking depth texture",format:"depth32float",size:e,usage:GPUTextureUsage.RENDER_ATTACHMENT})}async setup(e,t,i){const r=this.context.getDevice(),s=[{arrayStride:i[0].arrayStride+Float32Array.BYTES_PER_ELEMENT,attributes:[...i[0].attributes,{format:"float32",offset:32,shaderLocation:3}]}],a=(0,G.BJ)(r);this.pipeline=await r.createRenderPipelineAsync({label:"PickingPipeline",layout:r.createPipelineLayout({label:"Picking Pipeline layout",bindGroupLayouts:[a[G.Tq.CAMERA],a[G.Tq.TRANSFORM]]}),vertex:{module:e.vertex,entryPoint:"v_main",buffers:s},fragment:{module:e.fragment,entryPoint:"f_main",targets:[{format:"rgba32float"}]},primitive:{topology:"triangle-list",cullMode:"back"},depthStencil:{depthWriteEnabled:!0,depthCompare:"less",format:"depth32float"}}),this.createTexture(this.texSize),this.destinationBuffer=r.createBuffer({label:"PickDestination",size:this.bufferSize,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ}),this.renderPassDescriptor={label:"MousePickRenderPass",colorAttachments:[{view:null,clearValue:{r:0,g:0,b:0,a:0},loadOp:"clear",storeOp:"store"}],depthStencilAttachment:{view:null,depthClearValue:1,depthLoadOp:"clear",depthStoreOp:"store",stencilClearValue:0}},this.textures.setup(r,this.context.getCanvasFormat(),t)}setDrawModel(e){this.drawModel=e}setTransformBindGroups(e){this.transformBinGroups=e}}const E=1e-6,v=e=>S(E+e*E),S=e=>Number.parseFloat(e).toFixed(6);class R{constructor(e,t){var i=this;(0,r.A)(this,"drawModel",(function(e,t){let r=arguments.length>2&&void 0!==arguments[2]&&arguments[2];for(const[s,a]of i.nodesToDraw)a.buffers.forEach((n=>{let o=i.transformBinGroups.get(s);if(!o){const t=i.getAbsoluteAnimatedMatrix(s);o=p.setup(e,i.getBindGroupLayout(G.Tq.TRANSFORM),{transformMatrix:t,pickingColor:r?a.pickingColor:void 0},a.name)}t.setBindGroup(G.Tq.TRANSFORM,o),t.setBindGroup(G.Tq.MATERIAL,i.materialBuffer.getBindGroup(i.materialIndexes.get(n)||0)),r?(t.setVertexBuffer(0,n.getFaceBuffer()),t.draw(n.getFaceBufferCount())):(t.setVertexBuffer(0,n.getVertexBuffer()),t.setIndexBuffer(n.getIndexBuffer(),"uint16"),t.drawIndexed(n.getIndexCount(),1,0))}))})),(0,r.A)(this,"resize",(e=>{this.textures.resize(this.context.getDevice(),this.context.getCanvasFormat(),e)})),(0,r.A)(this,"getBindGroupLayout",(e=>this.bindGroupLayouts[e])),(0,r.A)(this,"getRenderPassDescriptor",(()=>this.pipeline.getRenderPassDescriptor())),(0,r.A)(this,"get",(()=>this.pipeline.get())),(0,r.A)(this,"getDrawNodes",(()=>this.nodesToDraw)),(0,r.A)(this,"getAnimations",(()=>this.animations)),(0,r.A)(this,"getFirstBufferLayout",(()=>this.firstBufferLayout)),(0,r.A)(this,"getByPickColor",(async e=>{const t=this.nodesPerColorPicking.get(e[0]),i=this.nodes.get(t);this.nodesToDraw.get(t);let r,s;if(i){const t=await this.db.getMeshMatrixData(i.mesh);if(t){const e=t.matrix;s=new l.A,s.setRaw(e)}const a=this.facesPerMeshPerColorPicking.get(i.mesh);if(a){const t=a.get(e[1]),s=await this.db.getMeshFaceData(`${i.mesh}-${t}`);s&&(r=s.vertices)}}return{positions:r,node:i,matrix:s}})),this.context=e,this.config=t,this.pipeline=new g,this.textures=new T,this.db=null}async setupDb(e){this.db=e,await this.db.setup()}async setup(e,t,i,r){let s=arguments.length>4&&void 0!==arguments[4]&&arguments[4];const o=this.context.getDevice(),u=e.get("nodes");this.nodes=u,this.matrixBuffersMaps=new Map,this.materialIndexes=new Map;const l=new Map;this.facesPerMeshPerColorPicking=new Map;const h=[];for(const[t,i]of e.get("meshes")){let e=[];const r=new Map;let s=0;for(let n of i.primitives){const u=new a;u.setup(o,n),this.materialIndexes.set(u,n.material),e.push(u);const l=n.bufferIndex.length/3,d=[],c=this.db?R.getIndiceVerticesMap(n):null;for(let e=0;e<l;e++){if(c){const i=3*e,r=n.bufferIndex.at(i),a=n.bufferIndex.at(i+1),o=n.bufferIndex.at(i+2),u=c.get(r),l=c.get(a),d=c.get(o);h.push({meshIdIndex:`${t}-${s}`,vertices:[u,l,d]})}const i=v(s);r.set(i,s),s++;const a=Number.parseFloat(i);d.push(a,a,a)}u.setupForFaces(o,n,d),i.name,u.setupFaceColorPick(o,[0,0,0,0])}this.facesPerMeshPerColorPicking.set(t,r),l.set(t,e)}this.db&&h.length&&await this.db.addFacesData(h);const d=l.values().next().value[0];this.firstBufferLayout=d.getLayout();let c=[this.firstBufferLayout];s&&(c=[{arrayStride:this.firstBufferLayout.arrayStride+Float32Array.BYTES_PER_ELEMENT,attributes:[...this.firstBufferLayout.attributes,{format:"float32",offset:32,shaderLocation:3}]}]),this.bindGroupLayouts=(0,G.YM)(o),await this.pipeline.setup(o,t,e.get("pipeline"),c,this.context.getCanvasFormat(),[this.bindGroupLayouts[G.Tq.CAMERA],this.bindGroupLayouts[G.Tq.TRANSFORM],this.bindGroupLayouts[G.Tq.MATERIAL],this.bindGroupLayouts[G.Tq.LIGHT]]),this.pipeline.setupRenderPassDescriptor(),this.animations=new B(e.get("animations"),u),this.materialBuffer=new n,await this.materialBuffer.setup(o,this.getBindGroupLayout(G.Tq.MATERIAL),e.get("materials"),e.get("textures"),r),this.buildDrawNodes(u,l),this.transformBinGroups=this.buildTransformBindGroups(this.getBindGroupLayout(G.Tq.TRANSFORM)),this.textures.setup(o,this.context.getCanvasFormat(),i);const p=this.db?[]:null;if(p){for(const[e,t]of this.nodesToDraw)p.push({meshId:e,matrix:t.matrix.get()});await this.db.addNodeMatricesData(p)}}static getIndiceVerticesMap(e){const t=new Map,i=e.arrayStride/Float32Array.BYTES_PER_ELEMENT,r=e.bufferVertex.length/i;for(let s=0;s<r;s++){const r=s*i,a=[e.bufferVertex.at(r),e.bufferVertex.at(r+1),e.bufferVertex.at(r+2)];t.set(s,a)}return t}static getAbsoluteMatrix(e,t){const i=t.get(e);if(!i)throw Error("node not found in getAbsoluteMatrix");if(i.parent){const e=d.get(i);return i.paths.forEach((i=>{const r=t.get(i),s=d.get(r);e.multiply(s)})),e}return d.get(i)}getAbsoluteAnimatedMatrix(e){const t=this.nodes.get(e);if(!t)throw Error("node not found in getAbsoluteMatrix");if(t.parent){const e=d.get(t);return t.paths.forEach((t=>{if(this.animations.isNodeHasAnimation(t)){const i=this.animations.handleLocalTransform(t);e.multiply(i)}else{const i=this.nodes.get(t),r=d.get(i);e.multiply(r)}})),e}return this.animations.isNodeHasAnimation(e)?this.animations.handleLocalTransform(e):d.get(t)}static getMeshId(e,t){if(e.isInstance){return t.get(e.children[0]).mesh}return e.mesh}buildDrawNodes(e,t){this.nodesToDraw=new Map,this.nodesPerColorPicking=new Map;let i=0;for(const[r,s]of e){const a=R.getMeshId(s,e);if(void 0===a||s.isInstanceRef||!s.isInstance&&s.children)continue;const n=R.getAbsoluteMatrix(r,e),o=t.get(a),u=this.animations.isNodeHasAnimation(r)||s.paths?.some(this.animations.isNodeHasAnimation),l=v(i);this.nodesToDraw.set(r,{name:s.name,buffers:o,matrix:n,pickingColor:[Number.parseFloat(l),0,0,1],hasAnimation:u}),this.nodesPerColorPicking.set(l,r),i++}}buildTransformBindGroups(e){const t=this.context.getDevice(),i=new Map;for(const[r,s]of this.nodesToDraw){const a=s.hasAnimation?void 0:p.setup(t,e,{transformMatrix:s.matrix,pickingColor:s.pickingColor});i.set(r,a)}return i}updateAnimations(e){this.animations&&this.animations.update(e)}update(){this.pipeline.update(this.context.getCurrentTexture().createView(),this.textures.getRenderTargetView(),this.textures.getDepthTextureView())}}class C{constructor(e){(0,r.A)(this,"render",((e,t,i)=>{const r=this.context.getDevice(),s=r.createCommandEncoder({label:"ShadowCommandEncoder"}),a=s.beginRenderPass(this.renderPassDescriptor);a.setPipeline(this.pipeline),a.setBindGroup(G.Tq.CAMERA,e),this.drawModel(r,a,t,i),a.end(),r.queue.submit([s.finish()])})),(0,r.A)(this,"drawModel",((e,t,i,r)=>{for(const[e,r]of i)r.buffers.forEach((i=>{let r=this.transformBinGroups.get(e);r&&(t.setBindGroup(G.Tq.TRANSFORM,r),t.setVertexBuffer(0,i.getVertexBuffer()),t.setVertexBuffer(1,i.getFaceColorBuffer()),t.setIndexBuffer(i.getIndexBuffer(),"uint16"),t.drawIndexed(i.getIndexCount()))}))})),(0,r.A)(this,"getBindGroupLayout",(e=>this.pipeline.getBindGroupLayout(e))),(0,r.A)(this,"getDepthTexture",(()=>this.depthTexture)),(0,r.A)(this,"getDepthTextureView",(()=>this.textureDepthView)),(0,r.A)(this,"getSize",(()=>this.texSize)),this.context=e,this.pipeline=void 0,this.texSize={width:2048,height:2048},this.textureDepthView}async setup(e,t){const i=this.context.getDevice(),r=(0,G.k6)(i);this.pipeline=await i.createRenderPipelineAsync({label:"ShadowPipeline",layout:i.createPipelineLayout({label:"Shadow Pipeline layout",bindGroupLayouts:r}),vertex:{module:e.vertex,entryPoint:"v_main",buffers:[{arrayStride:32,attributes:[{shaderLocation:0,format:"float32x3",offset:0},{shaderLocation:1,format:"float32x3",offset:12},{shaderLocation:2,format:"float32x2",offset:24}]}]},primitive:{topology:"triangle-list",cullMode:"back"},depthStencil:{depthWriteEnabled:!0,depthCompare:"less",format:"depth32float"}}),this.depthTexture=i.createTexture({label:"shadow depth texture",size:{width:2048,height:2048,depthOrArrayLayers:1},format:"depth32float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING}),this.textureDepthView=this.depthTexture.createView({dimension:"2d",format:"depth32float",aspect:"depth-only"}),this.renderPassDescriptor={label:"Shadow render pass",colorAttachments:[],depthStencilAttachment:{view:this.textureDepthView,depthClearValue:1,depthLoadOp:"clear",depthStoreOp:"store",stencilClearValue:0}}}setTransformBindGroups(e){this.transformBinGroups=e}getShadowMapBindGroupEntries(e,t){const i=e.createBuffer({label:"LightPositionBuffer",size:3*Float32Array.BYTES_PER_ELEMENT,usage:window.GPUBufferUsage.UNIFORM|window.GPUBufferUsage.COPY_DST,mappedAtCreation:!0});return new Float32Array(i.getMappedRange()).set(t),i.unmap(),[{binding:3,resource:e.createSampler({magFilter:"nearest",minFilter:"nearest",mipmapFilter:"nearest",compare:"less",addressModeU:"clamp-to-edge",addressModeV:"clamp-to-edge",addressModeW:"clamp-to-edge"})},{binding:4,resource:this.textureDepthView},{binding:5,resource:{buffer:i}}]}}class D{constructor(e){this.context=e,this.depthTextureFormat="depth32float",this.size={width:5,height:7}}setup(e,t){this.size=t;const i=this.context.getDevice(),r=i.createBindGroupLayout({label:"unfilterable-bgl",entries:[{binding:0,visibility:GPUShaderStage.FRAGMENT,sampler:{type:"non-filtering"}},{binding:1,visibility:GPUShaderStage.FRAGMENT,texture:{sampleType:"unfilterable-float"}}]});this.pipeline=i.createRenderPipeline({label:"DebugTexturePipeline",layout:i.createPipelineLayout({bindGroupLayouts:[r]}),vertex:{module:e.vertex,entryPoint:"v_main"},fragment:{module:e.fragment,entryPoint:"f_main",targets:[{format:this.context.getCanvasFormat(),blend:f.a}]},depthStencil:{depthWriteEnabled:!0,depthCompare:"less",format:this.depthTextureFormat},multisample:{count:4}})}setData(){const e=[255,0,0,255],t=[255,255,0,255],i=[0,0,255,255],r=()=>[e,t,i][Math.floor(3*Math.random())];return new Uint8Array(Array.from({length:this.size.height}).map((()=>Array.from({length:this.size.width}).map(r))).flat(2))}setTexture(e){const t=this.context.getDevice();this.bindGroup=t.createBindGroup({label:"debug texture bind group",layout:this.pipeline.getBindGroupLayout(0),entries:[{binding:0,resource:t.createSampler()},{binding:1,resource:e.createView()}]})}updateTexture(){this.context.getDevice().queue.writeTexture({texture:this.texture},this.setData(),{bytesPerRow:4*this.size.width},this.size)}render(e){e.setPipeline(this.pipeline),e.setBindGroup(0,this.bindGroup),e.draw(6)}}}}]);