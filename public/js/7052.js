"use strict";(self.webpackChunkdovotori_portfolio=self.webpackChunkdovotori_portfolio||[]).push([[7052,7719,552],{57719:(n,t,e)=>{e.r(t),e.d(t,{default:()=>a});const a="\nattribute vec3 position;\nattribute vec2 texture;\nvarying vec2 fragTexture;\nuniform float flipY; // 1 ou -1\n\nvoid main() {\n  fragTexture = texture;\n  gl_Position = vec4(position.x, position.y * flipY, position.z, 1.0);\n}\n"},87052:(n,t,e)=>{e.r(t),e.d(t,{default:()=>i});var a=e(20552),r=e(57719),o="\nprecision mediump float;\n\nuniform sampler2D textureMap;\nuniform float time;\n\nvarying vec2 fragTexture;\n\n".concat(a.PI,"\n\nmat2 rot(float th){ float cs = cos(th), si = sin(th); return mat2(cs, -si, si, cs); }\n\n#define SHARP_X 4.0\n#define SHARP_Y 4.0\n\nvoid main() {\n\tvec2 p = fragTexture * 2.0 - 1.0;\n\n  float rotZ = PI * 0.25;\n  p *= rot(rotZ);\n\n  float a = atan(p.y, p.x);\n  float r = pow(pow(p.x * p.x, SHARP_X) + pow(p.y * p.y, SHARP_Y), 1.0 / 8.0);\n  \n  // index texture by (animated inverse) radious and angle\n  vec2 uv = vec2( 0.3 / r + 0.2 * time, a / PI);\n\n  vec4 color = vec4(0.5, 0.3, 0.6, 0.0);\n  \n  if (fragTexture.y > 0.5) {\n    float stripX = mod(uv.y, 0.1);\n    if (stripX > 0.0 && stripX < 0.005) {\n      color.a = cos(uv.x * 2.0) * 6.0;\n    }\n\n    float stripX2 = 0.1 + mod(uv.y, 0.2);\n    if (stripX2 > 0.15 && stripX2 < 0.155) {\n      color.a = sin(uv.x) * 4.0;\n    }\n  }\n\n  // color.xyz *= r; // darken at the center   \n\tgl_FragColor = color;\n}\n");const i={vertex:r.default,fragment:o,attributes:["position","texture"],uniforms:["flipY","textureMap","time"]}},20552:(n,t,e)=>{e.r(t),e.d(t,{PI:()=>a,TWO_PI:()=>r,attributeColors:()=>o,funcGradiant:()=>l,funcGrain:()=>u,funcMap:()=>f,varyingColors:()=>i});var a="\n#define PI 3.14159265359\n",r="\n#define TWO_PI 6.28318530718\n",o="\nattribute vec3 ambiant;\nattribute vec3 diffuse;\nattribute vec3 specular;\nattribute float specDensity;\nattribute float opacity;\n",i="\nvarying vec3 fragAmbiant;\nvarying vec3 fragDiffuse;\nvarying vec3 fragSpecular;\nvarying float fragSpecDensity;\nvarying float fragOpacity;\n",f="\nfloat funcMap(float valeur, float minRef, float maxRef, float minDest, float maxDest) {\n  float result = minDest + (valeur - minRef) * (maxDest - minDest) / (maxRef - minRef);\n  if(result > maxDest){ result = maxDest; } else if(result < minDest){ result = minDest; }\n  return result;\n}\n",u="\nvec4 funcGrain(vec2 uv, float time, float strength) {\n  float x = (uv.x + 4.0 ) * (uv.y + 4.0 ) * (time * 10.0);\n  return vec4(mod((mod(x, 13.0) + 1.0) * (mod(x, 123.0) + 1.0), 0.01)-0.005) * strength;\n}\n",l="\n".concat(f,"\nvec4 funcGradiant(vec4 color1, vec4 color2, float start, float end, float uvAxe) {\n  float mixValue = funcMap(uvAxe, start, end, 0.0, 1.0);\n  return mix(color1, color2, mixValue);\n}\n")}}]);