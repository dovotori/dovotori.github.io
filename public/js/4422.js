"use strict";(self.webpackChunkdovotori=self.webpackChunkdovotori||[]).push([[4422,552,4926],{94422:(n,e,t)=>{t.r(e),t.d(e,{default:()=>i});var o=t(20552),r=t(74926);const i={vertex:"\nattribute vec3 position;\nuniform mat4 projection;\nuniform mat4 model;\nuniform mat4 view;\n\nuniform float time;\nuniform float roadLength;\nuniform vec3 amplitude;\nuniform vec3 frequence;\n\nvarying vec3 fragPosition;\nvarying float depth;\n\n".concat(o.PI,"\n").concat(r.default,"\n\nvoid main() {\n  vec3 transformed = position.xyz;\n  \n  fragPosition = position;\n  depth = 1.0 - (transformed.z * 0.2 / roadLength);\n\n  vec3 distortion = getDistortion(transformed.z / roadLength, frequence, amplitude, time);\n  // vec3 distortion = vec3(0.0);\n\n  transformed.x += distortion.x;\n  transformed.z += distortion.y;\n  transformed.y += -1.0 * distortion.z;  \n  \n  gl_Position = projection * view * model * vec4(transformed, 1.0);\n}\n"),fragment:"\nprecision mediump float;\n\nvarying vec3 fragPosition;\nvarying float depth;\n\nuniform float roadWidth;\n\nvoid main() {\n  vec3 roadColor1 = vec3(13.0 / 255.0, 7.1 / 255.0, 32.9 / 255.0);\n  vec3 roadColor2 = vec3(193.0 / 255.0, 2.0 / 255.0, 117.0 / 255.0);\n  float lineWidth = 0.05;\n\n  vec3 color = roadColor1;\n  vec3 pos = fragPosition + 1.0 * 0.5;\n\n  if (\n    (pos.x > 0.5 - lineWidth && pos.x < 0.5 + lineWidth) // middle line\n    || pos.x > roadWidth - lineWidth\n    || pos.x < -roadWidth + 1.0 + lineWidth\n  ) {\n    color = roadColor2;\n  }\n\n  gl_FragColor = vec4(color, depth);\n}\n",attributes:["position"],uniforms:["projection","model","view","time","roadLength","roadWidth","frequence","amplitude"]}},20552:(n,e,t)=>{t.r(e),t.d(e,{PI:()=>o,TWO_PI:()=>r,attributeColors:()=>i,funcGradiant:()=>l,funcGrain:()=>s,funcMap:()=>f,varyingColors:()=>a});var o="\n#define PI 3.14159265359\n",r="\n#define TWO_PI 6.28318530718\n",i="\nattribute vec3 ambiant;\nattribute vec3 diffuse;\nattribute vec3 specular;\nattribute float specDensity;\nattribute float opacity;\n",a="\nvarying vec3 fragAmbiant;\nvarying vec3 fragDiffuse;\nvarying vec3 fragSpecular;\nvarying float fragSpecDensity;\nvarying float fragOpacity;\n",f="\nfloat funcMap(float valeur, float minRef, float maxRef, float minDest, float maxDest) {\n  float result = minDest + (valeur - minRef) * (maxDest - minDest) / (maxRef - minRef);\n  if(result > maxDest){ result = maxDest; } else if(result < minDest){ result = minDest; }\n  return result;\n}\n",s="\nvec4 funcGrain(vec2 uv, float time, float strength) {\n  float x = (uv.x + 4.0 ) * (uv.y + 4.0 ) * (time * 10.0);\n  return vec4(mod((mod(x, 13.0) + 1.0) * (mod(x, 123.0) + 1.0), 0.01)-0.005) * strength;\n}\n",l="\n".concat(f,"\nvec4 funcGradiant(vec4 color1, vec4 color2, float start, float end, float uvAxe) {\n  float mixValue = funcMap(uvAxe, start, end, 0.0, 1.0);\n  return mix(color1, color2, mixValue);\n}\n")},74926:(n,e,t)=>{t.r(e),t.d(e,{default:()=>o});const o="\nfloat nsin(float val) {\n  return sin(val) * 0.5 + 0.5;\n}\n\nvec3 getDistortion(float progress, vec3 frequence, vec3 amplitude, float time) {\n  float movementProgressFix = 0.02;\n  float X = cos(progress * PI * frequence.x + time)\n    * amplitude.x - cos(movementProgressFix * PI * frequence.x + time) * amplitude.x;\n  float Y = nsin(progress * PI * frequence.y + time)\n    * amplitude.y - nsin(movementProgressFix * PI * frequence.y + time)* amplitude.y;\n  float Z = nsin(progress * PI * frequence.z + time)\n    * amplitude.z - nsin(movementProgressFix * PI * frequence.z + time)* amplitude.z;\n  return vec3(X, Y, Z);\n}\n"}}]);