"use strict";(self.webpackChunkdovotori=self.webpackChunkdovotori||[]).push([[4937],{44937:(e,t,r)=>{r.r(t),r.d(t,{IndexedDb:()=>s});class s{constructor(e){this.db=null,this.dbName=e,this.objectStoreAlreadyExist={}}deleteDb(){return new Promise(((e,t)=>{const r=window.indexedDB.deleteDatabase(this.dbName);r.onerror=e=>{t(e)},r.onsuccess=t=>{e(t.result)}}))}setup(e){return new Promise(((t,r)=>{const s=window.indexedDB.open(this.dbName);s.onerror=e=>{r(e)},s.onupgradeneeded=t=>{this.db=t.target.result,e.forEach((e=>{this.db.createObjectStore(e.name,{keyPath:e.keyPath}).createIndex(e.keyPath,e.keyPath,{unique:e.unique})}))},s.onsuccess=r=>{this.db=r.target.result,e.forEach((e=>{this.db.objectStoreNames.contains(e.name)&&(this.objectStoreAlreadyExist[e.name]=!0)})),t()}}))}upsertData(e,t){return new Promise(((r,s)=>{this.db||s("db is not yet defined.");const o=this.db.transaction([e],"readwrite");o.oncomplete=e=>{r(e)},o.onerror=e=>{s(e)};const n=o.objectStore(e);t.forEach((e=>{const t=n.put(e);t.onsuccess=()=>{},t.onerror=e=>{s(e)}}))}))}getData(e,t){return new Promise(((r,s)=>{const o=this.db.transaction([e]).objectStore(e).get(t);o.onerror=e=>{s(e)},o.onsuccess=()=>{r(o.result)}}))}isStoreExist(e){return this.objectStoreAlreadyExist[e]??!1}}}}]);