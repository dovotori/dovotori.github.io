import Delaunay from"../../labo/lib/delaunay";import fast from"../../labo/lib/fastcorner";const getGrayScaleBuffer=(e,t,a)=>{const r=new Uint8Array(t*a);let o=0;for(let n=0;n<a;n++)for(let a=0;a<t;a++){const l=t*n+a<<2,s=(e[l]>>2)+(e[l+1]>>1)+(e[l+2]>>2);r[o++]=s}return r},computeArea=(e,t,a,r,o,n)=>Math.abs((e*(r-n)+a*(n-t)+o*(t-r))/2),isInside=(e,t,a,r,o,n,l,s)=>computeArea(e,t,a,r,o,n)===computeArea(l,s,a,r,o,n)+computeArea(e,t,l,s,o,n)+computeArea(e,t,a,r,l,s),getColorPixelFromBuffer=(e,t,a,r)=>{const o=4*(r*Math.max(0,a-1)+t);return e.subarray(o,o+4).values()},getAverageColorOnTriangle=(e,t,a,r,o,n,l,s)=>{const u=Math.max(t,Math.max(r,n)),c=Math.min(t,Math.min(r,n)),i=Math.max(a,Math.max(o,l)),h=Math.min(a,Math.min(o,l)),m={r:0,g:0,b:0};let f=0;for(let g=c;g<=u;g++)for(let u=h;u<=i;u++)if(isInside(t,a,r,o,n,l,g,u)){const t=getColorPixelFromBuffer(e,g,u,s);m.r+=t.next().value,m.g+=t.next().value,m.b+=t.next().value,f++}return m.r/=f,m.g/=f,m.b/=f,m},computeDelaunay=({data:e,width:t,height:a,threshold:r})=>{const o=getGrayScaleBuffer(e,t,a),n=fast.detect(o,t,a,r,!0),l=n.reduce(((e,t)=>(e.push([t.x,t.y]),e)),[]);l.push([0,0],[t-1,0],[0,a-1],[t-1,a-1]);const s=Delaunay.triangulate(l),u=[];for(let a=0;a<s.length;a+=3){const r=l[s[a]][0],o=l[s[a]][1],n=l[s[a+1]][0],c=l[s[a+1]][1],i=l[s[a+2]][0],h=l[s[a+2]][1],m=getAverageColorOnTriangle(e,r,o,n,c,i,h,t);u.push({x0:r,y0:o,x1:n,y1:c,x2:i,y2:h,color:m})}return{coors:u,width:t,height:a,corners:n}},computeColor=({data:e,width:t,height:a,green:r,red:o,blue:n,bright:l,grey:s})=>{const u=e;for(let t=0;t<=e.length;t+=4){const a=e[t]*o,c=e[t+1]*r,i=e[t+2]*n;if(u[t]=a,u[t+1]=c,u[t+2]=i,s){const e=Math.min(Number.parseInt(a+c+i/3,10),255);u[t]=e,u[t+1]=e,u[t+2]=e}u[t]*=l,u[t+1]*=l,u[t+2]*=l}return{buffer:u,width:t,height:a}};self.onmessage=e=>{const{type:t,payload:a,id:r}=e.data;let o=null;switch(t){case"delaunay":o=computeDelaunay(a);break;case"color":o=computeColor(a)}self.postMessage({type:t,id:r,payload:o})};