import fast from"../../labo/lib/fastcorner";import Delaunay from"../../labo/lib/delaunay";const getGrayScaleBuffer=(e,t,a)=>{const r=new Uint8Array(t*a);let o=0;for(let n=0;n<a;n++)for(let a=0;a<t;a++){const h=t*n+a<<2,l=(e[h]>>2)+(e[h+1]>>1)+(e[h+2]>>2);r[o++]=l}return r},computeArea=(e,t,a,r,o,n)=>Math.abs((e*(r-n)+a*(n-t)+o*(t-r))/2),isInside=(e,t,a,r,o,n,h,l)=>computeArea(e,t,a,r,o,n)===computeArea(h,l,a,r,o,n)+computeArea(e,t,h,l,o,n)+computeArea(e,t,a,r,h,l),getColorPixelFromBuffer=(e,t,a,r)=>{const o=4*(r*Math.max(0,a-1)+t);return e.subarray(o,o+4).values()},getAverageColorOnTriangle=(e,t,a,r,o,n,h,l)=>{const s=Math.max(t,Math.max(r,n)),u=Math.min(t,Math.min(r,n)),c=Math.max(a,Math.max(o,h)),i=Math.min(a,Math.min(o,h)),m={r:0,g:0,b:0,a:0};let f=0;for(let g=u;g<=s;g++)for(let s=i;s<=c;s++)if(isInside(t,a,r,o,n,h,g,s)){const t=getColorPixelFromBuffer(e,g,s,l);m.r+=t.next().value,m.g+=t.next().value,m.b+=t.next().value,m.a+=t.next().value,f++}return m.r/=f,m.g/=f,m.b/=f,m.a/=f,m.r=Math.round(m.r),m.g=Math.round(m.g),m.b=Math.round(m.b),m},random=(e,t)=>Math.round(Math.random()*(t-e)+e),computeEffect=({data:e,canvas:t,segment:a})=>{const{width:r,height:o}=t,{width:n,height:h,margin:l=1}=a,s=[];let u=0;for(let t=0;t<=o-h+l;t+=h+l){for(;u<r;){const a=(c=n.min,i=n.max,Math.round(Math.random()*(i-c)+c)),o=u+Math.floor(a/2),m=4*((t+Math.floor(h/2))*r+o);if(0!==e[m+3]&&u+a<r){const r=e[m],o=e[m+1],n=e[m+2];s.push({x:u,y:t,width:a,height:h,color:{r,g:o,b:n}})}u+=a+l}u=0}var c,i;return{coors:s,width:r,height:o,segmentHeight:h}},computeDelaunay=({data:e,width:t,height:a,threshold:r})=>{const o=getGrayScaleBuffer(e,t,a),n=fast.detect(o,t,a,r,!0),h=n.reduce(((e,t)=>(e.push([t.x,t.y]),e)),[]);h.push([0,0],[t-1,0],[0,a-1],[t-1,a-1]);const l=Delaunay.triangulate(h),s=[];for(let a=0;a<l.length;a+=3){const r=h[l[a]][0],o=h[l[a]][1],n=h[l[a+1]][0],u=h[l[a+1]][1],c=h[l[a+2]][0],i=h[l[a+2]][1],m=getAverageColorOnTriangle(e,r,o,n,u,c,i,t);s.push({x0:r,y0:o,x1:n,y1:u,x2:c,y2:i,color:m})}return{coors:s,width:t,height:a,corners:n}},computeColor=({data:e,width:t,height:a,green:r,red:o,blue:n,bright:h,grey:l})=>{const s=e;for(let t=0;t<=e.length;t+=4){const a=e[t]*o,u=e[t+1]*r,c=e[t+2]*n;if(s[t]=a,s[t+1]=u,s[t+2]=c,l){const e=Math.min(Number.parseInt(a+u+c/3,10),255);s[t]=e,s[t+1]=e,s[t+2]=e}s[t]*=h,s[t+1]*=h,s[t+2]*=h}return{buffer:s,width:t,height:a}};self.onmessage=e=>{const{type:t,payload:a,id:r}=e.data;let o=null;switch(t){case"delaunay":o=computeDelaunay(a);break;case"color":o=computeColor(a);break;case"effect":o=computeEffect(a)}self.postMessage({type:t,id:r,payload:o})};